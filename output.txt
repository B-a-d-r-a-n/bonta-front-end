==== START ./.cursorrules ====
# .cursorrules for Angular 20 E-commerce Project

# Last Updated: July 2025

# Project Overview: Angular 20 e-commerce front-end with TanStack Query for server/client state, component-specific Signals for local UI state, NgRx for complex client-side state (checkout, filters), PrimeNG with Tailwind CSS for UI, and Feature-Based Structure. Integrates with a .NET e-commerce API.

## General Rules

- **Angular Version**: Use Angular 20 (latest as of July 2025). Follow Angular best practices per the official documentation: https://angular.dev/
- **Zoneless Change Detection**: Use zoneless change detection for performance. Configure in `app.config.ts` with `provideZonelessChangeDetection()`. Docs: https://angular.dev/guide/essentials/change-detection#zoneless
- **Feature-Based Structure**: Organize code by features (`products/`, `cart/`, `orders/`, `user/`, `payments/`) with subfolders for `components/`, `queries/` (TanStack Query), and `store/` (NgRx). See project structure: https://angular.dev/guide/style-guide#application-structure
- **TypeScript**: Use strict TypeScript (v5.5+). Enable `strict` mode in `tsconfig.json`. Docs: https://www.typescriptlang.org/docs/
- **Accessibility (A11y)**: Follow WCAG 2.2 guidelines (Level AA). Ensure ARIA attributes, keyboard navigation, and semantic HTML. Docs: https://www.w3.org/TR/WCAG22/
  - Use `aria-label`, `role`, and `tabindex` where needed.
  - Ensure PrimeNG components are accessible (e.g., `<p-button>` with `aria-label`).
  - Test with screen readers (e.g., NVDA, VoiceOver).
- **UI/UX Conventions**: Follow modern e-commerce UI/UX patterns (e.g., Material Design, Fluent Design). Ensure responsive design with Tailwind CSS and clear user feedback (e.g., toasts, loading states). Reference: https://m2.material.io/design
- **Code Style**: Follow Angular Style Guide. Use ESLint with `@angular-eslint` and Prettier for consistent formatting. Docs: https://angular.dev/guide/style-guide

## Data Models & Type Safety

- **Model Location**: Place all interface definitions in `src/app/core/models/` organized by domain:

  - `basket.model.ts` - Basket and cart-related interfaces
  - `product.model.ts` - Product, brand, and type interfaces
  - `order.model.ts` - Order and delivery method interfaces
  - `auth.model.ts` - Authentication and user interfaces
  - `error.model.ts` - Error handling interfaces
  - `paginated-response.model.ts` - Generic pagination interface

- **Required Model Interfaces**:

  ```typescript
  // Basket Models
  export interface BasketDTO {
    id: string;
    items: BasketItemDTO[];
    paymentIntentId?: string;
    clientSecret?: string;
    deliveryMethodId?: number;
    shippingPrice: number;
  }

  export interface BasketItemDTO {
    id: number; // Product ID
    productName: string;
    pictureUrl: string;
    price: number;
    quantity: number;
  }

  // Product Models
  export interface ProductResponse {
    id: number;
    name: string;
    description: string;
    pictureUrl: string;
    price: number;
    productType: string;
    productBrand: string;
  }

  export interface ProductQueryParameters {
    brandId?: number;
    typeId?: number;
    sort: ProductSortingOptions;
    search?: string;
    pageIndex: number;
    pageSize: number;
  }

  export enum ProductSortingOptions {
    NameAsc = "NameAsc",
    NameDesc = "NameDesc",
    PriceAsc = "PriceAsc",
    PriceDesc = "PriceDesc",
  }

  // Order Models
  export interface OrderRequest {
    basketId: string;
    shipToAddress: AddressDTO;
    deliveryMethodId: number;
  }

  export interface OrderResponse {
    id: string; // Guid as string
    buyerEmail: string;
    orderDate: string; // ISO date string
    shipToAddress: AddressDTO;
    deliveryMethod: string;
    items: OrderItemDTO[];
    status: string;
    paymentIntentId: string;
    subtotal: number;
    total: number;
    deliveryCost: number;
  }

  // Authentication Models
  export interface LoginRequest {
    email: string;
    password: string;
  }

  export interface RegisterRequest {
    email: string;
    password: string;
    displayName: string;
    userName: string;
    phoneNumber?: string;
  }

  export interface UserResponse {
    email: string;
    displayName: string;
    token: string;
  }

  // Error Models
  export interface ErrorDetails {
    statusCode: number;
    errorMessage: string;
    errors?: string[];
  }

  export interface ValidationErrorResponse {
    statusCode: number;
    errorMessage: string;
    validationErrors: ValidationError[];
  }

  export interface ValidationError {
    field: string;
    errors: string[];
  }

  // Pagination Model
  export interface PaginatedResponse<T> {
    pageIndex: number;
    pageSize: number;
    count: number;
    data: T[];
  }
  ```

- **Type Safety Rules**:
  - Always use these exact interface names and structures
  - Import models from `@core/models/` using barrel exports
  - Use strict typing for all API responses and requests
  - Implement proper type guards for runtime type checking

## Dependency-Specific Rules

1. **TanStack Query for Angular (@tanstack/angular-query-experimental)**

   - **Purpose**: Manage server-side state (e.g., `/api/Baskets`, `/api/Products`, `/api/Orders`) and client-side state via cache.
   - **Rules**:
     - Use `injectQuery` and `injectMutation` in `queries/` folders (e.g., `cart.queries.ts`).
     - `injectQuery` syntax: Pass a function that returns the query options object:
       ```typescript
       query = injectQuery(() => ({
         queryKey: ["todos"],
         queryFn: () =>
           lastValueFrom(this.http.get<TodoResponse[]>("/api/todos")),
       }));
       ```
     - `injectMutation` syntax: Pass a function that returns the mutation options object:
       ```typescript
       mutation = injectMutation(() => ({
         mutationFn: (data: CreateTodoRequest) =>
           lastValueFrom(this.http.post<TodoResponse>("/api/todos", data)),
         onSuccess: () =>
           this.queryClient.invalidateQueries({ queryKey: ["todos"] }),
       }));
       ```
     - Access query/mutation state using signal syntax: `query.data()`, `query.isPending()`, `query.error()`, `mutation.isPending()`.
     - Use `inject(QueryClient)` to access the QueryClient for operations like `invalidateQueries`.
     - Convert Angular HttpClient Observables to Promises using `lastValueFrom` for compatibility with TanStack Query.
     - Implement optimistic updates with `queryClient.setQueryData` and rollback in `onError`.
     - Set `staleTime: 5 * 60 * 1000` (5 minutes) for caching unless specified otherwise.
     - Use `refetch()` in `ngOnInit` to ensure data is fetched or cached.
     - Avoid duplicating server state in Signals or NgRx; use `query.data()` directly.
     - **Retry Strategy**: Use `retry: 3` for mutations and `retry: 1` for queries by default.
     - **Error Handling**: Implement global error handling with `onError` callbacks and toast notifications using `ErrorDetails` and `ValidationErrorResponse` interfaces.
     - **Template Usage**: Use Angular control flow with signals: `@if (query.isPending()) { Loading... } @else if (query.error()) { Error } @else { {{ query.data() }} }`
   - **Docs**: https://tanstack.com/query/latest/docs/framework/angular/overview

2. **Angular Signals**

   - **Purpose**: Manage component-specific UI state (e.g., `addLoading`, `removeLoading`, `saving`) and computed state (e.g., cart `itemCount`, `total`).
   - **Rules**:
     - Use `signal()` for local state (e.g., `saving = signal(false)`).
     - Use `computed()` for derived state (e.g., `itemCount` calculated from `BasketDTO.items`).
     - Avoid global Signals; use TanStack Query for shared server state and NgRx for complex client state.
     - Ensure reactivity in templates with `@if`, `@for`, and Signal bindings.
     - Use proper typing with signals: `signal<BasketDTO | null>(null)`, `computed<number>(() => ...)`
   - **Docs**: https://angular.dev/guide/signals

3. **NgRx SignalStore (v19.2.1)**

   - **Purpose**: Manage complex client-side state (e.g., checkout flow, product filters) using signal-based store.
   - **Rules**:
     - Use `signalStore` with `withState`, `withMethods`, and `withHooks` for feature stores.
     - Place NgRx SignalStore files in `store/` subfolders (e.g., `orders/store/`, `products/store/`).
     - Use `patchState` for state updates and computed signals for derived state.
     - Create feature stores for each domain (e.g., `CheckoutStore`, `ProductFilterStore`).
     - Use `withEntities` for entity management when needed.
     - Implement `withHooks` for side effects (e.g., saving filters to localStorage).
     - Avoid NgRx for server-synced state (e.g., cart items, products).
     - Use proper typing with interfaces: `withState<{ filters: ProductQueryParameters }>`
     - Example structure:
       ```typescript
       export const CheckoutStore = signalStore(
         { providedIn: "root" },
         withState<CheckoutState>({
           currentStep: CheckoutStep.Address,
           address: null as AddressDTO | null,
           deliveryMethod: null as DeliveryMethodResponse | null,
           orderRequest: null as OrderRequest | null,
         }),
         withMethods((store) => ({
           updateStep: (step: CheckoutStep) =>
             patchState(store, { currentStep: step }),
           setAddress: (address: AddressDTO) => patchState(store, { address }),
           setDeliveryMethod: (method: DeliveryMethodResponse) =>
             patchState(store, { deliveryMethod: method }),
         })),
         withHooks({
           onInit: (store) => {
             // Initialize from localStorage
           },
         })
       );
       ```
   - **Docs**: https://ngrx.io/guide/signals

4. **PrimeNG (v20.x)**

   - **Purpose**: Provide UI components (e.g., `<p-button>`, `<p-dropdown>`, `<p-inputtext>`).
   - **Rules**:
     - Use standalone components (e.g., `imports: [ButtonModule, DropdownModule]`).
     - Style with Tailwind CSS classes for consistency (e.g., `bg-blue-500 text-white p-2 rounded`).
     - Ensure accessibility: Add `aria-label`, `aria-disabled`, and keyboard support.
     - Wrap PrimeNG components in `shared/components/` for reusability (e.g., `button.component.ts`).
     - Use proper typing for component inputs: `[options]="brands() as BrandResponse[]"`
   - **Docs**: https://primeng.org/

5. **Tailwind CSS (v4.1)**
   - **Purpose**: Style PrimeNG components and custom UI for responsive design.
   - **Rules**:
     - Configure in `styles.css` and `tailwind.config.js`.
     - Use utility-first classes (e.g., `flex justify-between`, `grid grid-cols-3 gap-4`).
     - Ensure responsive design with mobile-first classes (e.g., `sm:`, `md:`).
     - Maintain WCAG 2.2 contrast ratios (e.g., use `text-white` on `bg-blue-500`).
   - **Docs**: https://tailwindcss.com/docs

## API Integration Rules

- **API Base URL**: Use environment variables (`environment.ts`, `environment.prod.ts`) for `/api/` endpoints.
- **Endpoints & Type Mapping**:
  - `/api/Authentication`:
    - POST `/login` - `LoginRequest` → `UserResponse`
    - POST `/register` - `RegisterRequest` → `UserResponse`
    - GET `/checkEmailExists/{email}` - `boolean`
    - GET `/address` - `AddressDTO`
    - PUT `/address` - `AddressDTO` → `AddressDTO`
    - GET `/currentUser` - `UserResponse`
  - `/api/Baskets`:
    - GET `/{id}` - `BasketDTO`
    - POST - `BasketDTO` → `BasketDTO`
    - DELETE `/{id}` - `void`
  - `/api/Orders`:
    - POST - `OrderRequest` → `OrderResponse`
    - GET - `OrderResponse[]`
    - GET `/deliveryMethods` - `DeliveryMethodResponse[]`
  - `/api/Payments`:
    - POST `/{basketId}` - `BasketDTO` (with payment intent)
    - POST `/WebHook` - webhook handling
  - `/api/Products`:
    - GET - `PaginatedResponse<ProductResponse>` with `ProductQueryParameters`
    - GET `/{id}` - `ProductResponse`
    - GET `/brands` - `BrandResponse[]`
    - GET `/types` - `TypeResponse[]`
- **Rules**:
  - Map API endpoints to TanStack Query in `queries/` with proper typing.
  - Use `HttpClient` with `lastValueFrom()` and generic types: `this.http.get<ProductResponse[]>(...)`
  - Handle authentication with `auth.interceptor.ts` to attach JWT tokens.
  - Use NgRx SignalStore for temporary state with proper interfaces.
  - Ensure error handling using `ErrorDetails` and `ValidationErrorResponse` interfaces.

## Error Handling Strategy

- **Global Error Interceptor**: Create `error.interceptor.ts` to handle HTTP errors globally using `ErrorDetails` interface.
- **Error Type Usage**: Use the defined error interfaces consistently:
  - `ErrorDetails` for general API errors
  - `ValidationErrorResponse` for form validation errors
  - `ValidationError` for individual field errors
- **TanStack Query Error Handling**:
  - Use `onError` callbacks with typed error parameters: `onError: (error: ErrorDetails) => {...}`
  - Implement global error handling with `queryClient.setMutationDefaults`
  - Show appropriate toast messages based on error types
  - Access errors using signal syntax: `query.error() as ErrorDetails`
- **NgRx SignalStore Error Handling**:
  - Use `patchState` to update error state with typed interfaces
  - Create computed signals for error messages
  - Implement error recovery methods in store

## Performance Optimization

- **Lazy Loading**: Use route-level and component-level lazy loading with standalone components:

  ```typescript
  // Route-level lazy loading
  {
    path: 'products',
    loadChildren: () => import('./features/products/products.routes').then(m => m.PRODUCTS_ROUTES)
  }

  // Component-level lazy loading
  {
    path: 'analytics',
    loadComponent: () => import('./components/analytics-dashboard/analytics-dashboard.component').then(m => m.AnalyticsDashboardComponent)
  }
  ```

- **Bundle Splitting**: Configure webpack to split bundles by feature and vendor libraries
- **Image Optimization**:
  - Use WebP format with fallbacks
  - Implement lazy loading for product images using `ProductResponse.pictureUrl`
  - Use responsive images with `srcset`
- **TanStack Query Optimization**:
  - Use `staleTime` and `cacheTime` appropriately
  - Implement background refetching for frequently updated data
  - Use `select` to prevent unnecessary re-renders
  - Implement proper cache invalidation for related data

## Project Structure

- **Core**: Global utilities (`services/`, `guards/`, `interceptors/`, `models/`, `constants/`, `enums/`).
- **Features**: Organize by feature (`products/`, `cart/`, `orders/`, `user/`, `payments/`).
  - `components/`: Standalone Angular components with PrimeNG and Signals.
  - `queries/`: TanStack Query with `injectQuery` and `injectMutation` for API calls and optimistic updates.
  - `store/`: NgRx SignalStore for complex client-side state (e.g., `orders/store/` for checkout).
- **Shared**: Reusable components (`button`, `dropdown`), utils (`cart.utils.ts`), layouts, pipes.
- **Models**: Centralized in `src/app/core/models/` with barrel exports.
- **Docs**: https://angular.dev/guide/style-guide#application-structure

## Testing Strategy

- **Unit Testing**:
  - Use Jest for components, services, and utilities
  - Test TanStack Query with mock query client and typed responses
  - Test NgRx with mock store and proper interface typing
  - Test accessibility with axe-core: https://www.deque.com/axe/
  - Mock API responses using the defined interfaces
- **Integration Testing**:
  - Test component interactions with TanStack Query signals and typed data
  - Test NgRx SignalStore state changes with proper interfaces
  - Test API integration with mock backends returning typed responses
- **E2E Testing**:
  - Use Cypress or Playwright for user journey testing
  - Test critical paths: login, add to cart, checkout
  - Test responsive design on different screen sizes
  - Validate proper error handling with different error types
- **Testing Patterns**:

  ```typescript
  // TanStack Query testing with types
  const mockQueryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  });

  const mockProductResponse: ProductResponse = {
    id: 1,
    name: "Test Product",
    description: "Test Description",
    pictureUrl: "test.jpg",
    price: 99.99,
    productType: "Electronics",
    productBrand: "TestBrand",
  };

  // NgRx SignalStore testing with typed state
  const testStore = signalStore(
    withState<TestState>({
      products: [] as ProductResponse[],
      loading: false,
      error: null as ErrorDetails | null,
    }),
    withMethods((store) => ({
      setProducts: (products: ProductResponse[]) =>
        patchState(store, { products }),
      setError: (error: ErrorDetails) => patchState(store, { error }),
    }))
  );
  ```

## Code Quality & Standards

- **ESLint Configuration**:
  ```json
  {
    "extends": [
      "@angular-eslint/recommended",
      "@angular-eslint/template/process-inline-templates"
    ],
    "rules": {
      "@angular-eslint/directive-selector": [
        "error",
        { "type": "attribute", "prefix": "app" }
      ],
      "@angular-eslint/component-selector": [
        "error",
        { "type": "element", "prefix": "app" }
      ],
      "prefer-const": "error",
      "no-unused-vars": "error",
      "@typescript-eslint/no-explicit-any": "error",
      "@typescript-eslint/explicit-function-return-type": "warn"
    }
  }
  ```
- **Git Commit Conventions**: Use Conventional Commits format:
  ```
  feat(products): add product filtering functionality
  fix(cart): resolve quantity update bug for BasketItemDTO
  docs(readme): update installation instructions
  refactor(models): reorganize interface definitions
  ```
- **Code Review Checklist**:
  - Accessibility compliance (WCAG 2.2 AA)
  - TypeScript strict mode compliance with proper interface usage
  - Proper error handling implementation using defined error interfaces
  - Performance considerations (lazy loading, caching)
  - Test coverage for new features with typed mocks

## Best Practices

- **Performance**:
  - Leverage zoneless change detection with Signals for automatic reactivity.
  - Use `computed()` signals for derived state with proper typing.
  - Leverage TanStack Query's `staleTime` for caching with typed responses.
  - Minimize NgRx SignalStore boilerplate; use only for complex state with proper interfaces.
  - Implement virtual scrolling for large lists using `PaginatedResponse<T>`.
- **Testing**:
  - Write unit tests with Jest using typed mocks and interfaces.
  - Test accessibility with tools like axe-core.
  - Maintain minimum 80% code coverage.
  - Use proper TypeScript types in all test scenarios.
- **UI/UX**:
  - Follow e-commerce conventions with proper data display using model interfaces.
  - Ensure mobile responsiveness with Tailwind's breakpoints.
  - Provide visual feedback with typed loading states and error messages.
  - Implement skeleton loading for better perceived performance.
- **Security**:
  - Sanitize user inputs using proper validation with `ValidationErrorResponse`.
  - Use `auth.interceptor.ts` for secure API calls with `UserResponse` token.
  - Validate API responses using TypeScript interfaces and type guards.
  - Implement Content Security Policy (CSP) headers.

## TanStack Query Examples

### Query Example with Proper Typing:

```typescript
// products.queries.ts
import { inject } from "@angular/core";
import { HttpClient } from "@angular/common/http";
import {
  injectQuery,
   QueryClient,
} from "@tanstack/angular-query-experimental";
import { lastValueFrom } from "rxjs";
import {
  ProductResponse,
  ProductQueryParameters,
  PaginatedResponse,
} from "@core/models";

@Injectable()
export class ProductsService {
  private http = inject(HttpClient);
  private queryClient = inject(QueryClient);

  getProducts = (params: ProductQueryParameters) =>
    injectQuery(() => ({
      queryKey: ["products", params],
      queryFn: () =>
        lastValueFrom(
          this.http.get<PaginatedResponse<ProductResponse>>("/api/products", {
            params: params as any,
          })
        ),
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: 1,
    }));

  getProduct = (id: number) =>
    injectQuery(() => ({
      queryKey: ["product", id],
      queryFn: () =>
        lastValueFrom(this.http.get<ProductResponse>(`/api/products/${id}`)),
      staleTime: 5 * 60 * 1000,
      retry: 1,
    }));
}
```

### Mutation Example with Proper Typing:

```typescript
// cart.queries.ts
import { inject } from "@angular/core";
import { HttpClient } from "@angular/common/http";
import {
  injectMutation,
  QueryClient,
} from "@tanstack/angular-query-experimental";
import { lastValueFrom } from "rxjs";
import { BasketDTO, BasketItemDTO, ErrorDetails } from "@core/models";

@Injectable()
export class CartService {
  private http = inject(HttpClient);
  private queryClient = inject(QueryClient);

  updateBasket = injectMutation(() => ({
    mutationFn: (basket: BasketDTO) =>
      lastValueFrom(this.http.post<BasketDTO>("/api/baskets", basket)),
    onSuccess: (updatedBasket: BasketDTO) => {
      this.queryClient.setQueryData(
        ["basket", updatedBasket.id],
        updatedBasket
      );
    },
    onError: (error: ErrorDetails) => {
      console.error("Failed to update basket:", error.errorMessage);
      // Handle error with toast notification
    },
    retry: 3,
  }));

  getBasket = (id: string) =>
    injectQuery(() => ({
      queryKey: ["basket", id],
      queryFn: () =>
        lastValueFrom(this.http.get<BasketDTO>(`/api/baskets/${id}`)),
      staleTime: 1 * 60 * 1000, // 1 minute for cart data
      retry: 1,
    }));
}
```

### Template Usage with Proper Typing:

```html
<!-- products.component.html -->
@if (productsQuery.isPending()) {
<div class="flex justify-center items-center h-64">
  <div
    class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"
  ></div>
</div>
} @else if (productsQuery.error()) {
<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
  <strong>Error:</strong> {{ (productsQuery.error() as
  ErrorDetails).errorMessage }}
</div>
} @else {
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
  @for (product of productsQuery.data()?.data; track product.id) {
  <div class="bg-white rounded-lg shadow-md overflow-hidden">
    <img
      [src]="product.pictureUrl"
      [alt]="product.name"
      class="w-full h-48 object-cover"
    />
    <div class="p-4">
      <h3 class="text-lg font-semibold text-gray-900">{{ product.name }}</h3>
      <p class="text-gray-600 text-sm mt-1">{{ product.productBrand }}</p>
      <p class="text-gray-800 text-sm mt-2">{{ product.description }}</p>
      <div class="flex justify-between items-center mt-4">
        <span class="text-xl font-bold text-blue-600"
          >{{ product.price | currency }}</span
        >
        <p-button
          (click)="addToCart(product)"
          [disabled]="addToCartMutation.isPending()"
          [label]="addToCartMutation.isPending() ? 'Adding...' : 'Add to Cart'"
          styleClass="p-button-sm"
        >
        </p-button>
      </div>
    </div>
  </div>
  }
</div>
}
```

## IDE Guidance

- **Code Generation**:
  - Generate components in `features/{feature}/components/` with `standalone: true` and proper imports.
  - Create TanStack Query files in `queries/` with proper typing using model interfaces.
  - Generate NgRx SignalStore files in `store/` with typed state using defined interfaces.
  - Always import and use the correct model interfaces from `@core/models`.
- **Refactoring**:
  - Ensure proper typing throughout the application using defined interfaces.
  - Use type guards for runtime type checking when necessary.
  - Refactor repetitive UI code into `shared/components/` with proper typing.
  - Extract common utilities into `shared/utils/` with typed parameters.
- **Debugging**:
  - Use NgRx DevTools for SignalStore debugging with typed state.
  - Check TanStack Query cache with proper type assertions.
  - Validate API responses match defined interfaces.
  - Use Angular DevTools for performance profiling.

## Future Expansion

- **API Expansion**: Add new `features/` folders with proper interface definitions in `@core/models`.
- **NgRx SignalStore**: Extend for new client-side state with proper typing.
- **TanStack Query**: Add new queries/mutations with proper interface usage.
- **Model Evolution**: Update interfaces as API evolves, maintaining backward compatibility.
- **Internationalization**: Implement Angular i18n for multi-language support.
- **Progressive Web App**: Add service worker for offline functionality and push notifications.

## Development Workflow

- **Branch Strategy**: Use GitFlow with feature branches for new development.
- **Pre-commit Hooks**: Run ESLint, Prettier, TypeScript compiler, and tests before commits.
- **CI/CD Pipeline**:
  - Run tests and linting on pull requests
  - Build and deploy to staging environment
  - Automated accessibility testing with axe-core
  - Type checking with strict TypeScript compilation
- **Documentation**: Maintain up-to-date README with setup instructions and API documentation including model interfaces.
==== END ./.cursorrules ====
==== START ./.editorconfig ====
# Editor configuration, see https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single
ij_typescript_use_double_quotes = false

[*.md]
max_line_length = off
trim_trailing_whitespace = false
==== END ./.editorconfig ====
==== START ./.gitignore ====
# See https://docs.github.com/get-started/getting-started-with-git/ignoring-files for more about ignoring files.

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.history/*

# Miscellaneous
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# System files
.DS_Store
Thumbs.db
==== END ./.gitignore ====
==== START ./.postcssrc.json ====
{
  "plugins": {
    "@tailwindcss/postcss": {
      "config": "./tailwind.config.js"
    }
  }
}
==== END ./.postcssrc.json ====
==== START ./.vscode/extensions.json ====
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=827846
  "recommendations": ["angular.ng-template"]
}
==== END ./.vscode/extensions.json ====
==== START ./.vscode/launch.json ====
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "name": "ng serve",
      "type": "chrome",
      "request": "launch",
      "preLaunchTask": "npm: start",
      "url": "http://localhost:4200/"
    },
    {
      "name": "ng test",
      "type": "chrome",
      "request": "launch",
      "preLaunchTask": "npm: test",
      "url": "http://localhost:9876/debug.html"
    }
  ]
}
==== END ./.vscode/launch.json ====
==== START ./.vscode/tasks.json ====
{
  // For more information, visit: https://go.microsoft.com/fwlink/?LinkId=733558
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "start",
      "isBackground": true,
      "problemMatcher": {
        "owner": "typescript",
        "pattern": "$tsc",
        "background": {
          "activeOnStart": true,
          "beginsPattern": {
            "regexp": "(.*?)"
          },
          "endsPattern": {
            "regexp": "bundle generation complete"
          }
        }
      }
    },
    {
      "type": "npm",
      "script": "test",
      "isBackground": true,
      "problemMatcher": {
        "owner": "typescript",
        "pattern": "$tsc",
        "background": {
          "activeOnStart": true,
          "beginsPattern": {
            "regexp": "(.*?)"
          },
          "endsPattern": {
            "regexp": "bundle generation complete"
          }
        }
      }
    }
  ]
}
==== END ./.vscode/tasks.json ====
==== START ./angular.json ====
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "boon-front-end": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "style": "scss"
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular/build:application",
          "options": {
            "browser": "src/main.ts",
            "tsConfig": "tsconfig.app.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "src/styles.scss"
            ],
            "server": "src/main.server.ts",
            "outputMode": "server",
            "ssr": {
              "entry": "src/server.ts"
            }
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kB",
                  "maximumError": "1MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "4kB",
                  "maximumError": "8kB"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular/build:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "boon-front-end:build:production"
            },
            "development": {
              "buildTarget": "boon-front-end:build:development"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular/build:extract-i18n"
        },
        "test": {
          "builder": "@angular/build:karma",
          "options": {
            "tsConfig": "tsconfig.spec.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "src/styles.scss"
            ]
          }
        }
      }
    }
  }
}
==== END ./angular.json ====
==== START ./ld.sh ====
#!/bin/bash

# Script to either load a structured file into directories/files or
# dump selected files from the current directory structure into a structured file.
# Operates relative to the current working directory where the script is called.
DEFAULT_OUTPUT_FILE="output.txt"
START_DELIM_PATTERN="^==== START (.*) ====$"
END_DELIM_PATTERN="^==== END (.*) ====$"

mode=""
fzf_mode=0
input_files=()
output_file=""
fzf_dump_selection_files=()

written_files=0
created_dirs=0

usage() {
	echo "Usage: $(basename "$0") [-l [-fzf | input_file...]] | [-d [-fzf] [output_file]]"
	echo ""
	echo "Modes:"
	echo "  -l, --load    : Load files/directories from structured input file(s)."
	echo "  -d, --dump    : Dump selected files from current directory structure into a file."
	echo ""
	echo "Options for Load Mode (-l):"
	echo "  -fzf          : Use fzf to interactively select one or more input files"
	echo "                  from the current directory recursively. Overrides specific"
	echo "                  input_file arguments."
	echo "  input_file... : Specify one or more input files to load (if -fzf not used)."
	echo "                  Defaults to '$DEFAULT_INPUT_FILE' if no files or -fzf specified."
	echo ""
	echo "Options for Dump Mode (-d):"
	echo "  -fzf          : Use fzf to interactively select one or more files from the"
	echo "                  current directory recursively TO BE DUMPED."
	echo "  output_file   : Specify the output file name. Defaults to '$DEFAULT_OUTPUT_FILE'."
	echo "                  This argument can come before or after -fzf for -d."
	echo ""
	echo "General Options:"
	echo "  -h, --help    : Show this help message."
	echo ""
	echo "Note: Exactly one mode (-l or -d) must be specified."
	echo "      -fzf requires either -l or -d to be set first."
	exit 1
}

temp_input_files=()
temp_output_file=""
temp_fzf=0

while [[ "$#" -gt 0 ]]; do
	case "$1" in
	-l | --load)
		if [[ -n "$mode" ]]; then
			echo "Error: Mode already set to '$mode'. Cannot set to 'load'." >&2
			usage
		fi
		mode="load"
		shift
		;;
	-d | --dump)
		if [[ -n "$mode" ]]; then
			echo "Error: Mode already set to '$mode'. Cannot set to 'dump'." >&2
			usage
		fi
		mode="dump"
		shift
		;;
	-fzf)
		if [[ -z "$mode" ]]; then
			echo "Error: -fzf option requires -l or -d mode to be specified first." >&2
			usage
		fi
		temp_fzf=1
		shift
		;;
	-h | --help)
		usage
		;;
	-*)
		echo "Error: Unknown option '$1'." >&2
		usage
		;;
	*) # Positional argument
		if [[ -z "$mode" ]]; then
			echo "Error: Positional arguments require -l or -d mode." >&2
			usage
		fi

		if [[ "$mode" == "load" ]]; then
			temp_input_files+=("$1")
		elif [[ "$mode" == "dump" ]]; then
			if [[ -n "$temp_output_file" ]]; then
				echo "Error: Multiple output files specified for dump mode." >&2
				usage
			fi
			temp_output_file="$1"
		fi
		shift
		;;
	esac
done

# --- Post-parsing validation and setup ---

if [[ -z "$mode" ]]; then
	echo "Error: No mode (-l or -d) specified." >&2
	usage
fi

# Apply temporary variables to final variables based on mode
fzf_mode=$temp_fzf

if [[ "$mode" == "load" ]]; then
	if [[ "$fzf_mode" -eq 1 ]]; then
		# Check if fzf is installed
		if ! command -v fzf &>/dev/null; then
			echo "Error: fzf is not installed." >&2
			echo "Please install fzf to use the -fzf option (e.g., brew install fzf, sudo apt-get install fzf)." >&2
			exit 1
		fi

		if [[ ${#temp_input_files[@]} -gt 0 ]]; then
			echo "Warning: Specific input file(s) were specified, but -fzf was also used." >&2
			echo "Using fzf selection for input files. The specified files will be ignored." >&2
		fi

		echo "Using fzf to select input file(s) for loading... Use TAB to select multiple, ENTER to confirm."
		# Use process substitution < <(...) to pipe find/fzf output directly to readarray
		readarray -d $'\0' -t input_files < <(find . -type f -not -path '*/\.git/*' -not -path '*/node_modules/*' -print0 | fzf --read0 --print0 --multi --cycle --exit-0 --prompt="Select input file(s) to load > ")
		fzf_status=$? # Capture fzf exit status

		if [[ "$fzf_status" -ne 0 ]]; then
			echo "File selection cancelled via fzf (exit code $fzf_status). Exiting." >&2
			exit 1
		fi

		for i in "${!input_files[@]}"; do
			input_files[$i]="${input_files[$i]%$'\n'}"
		done

		if [[ ${#input_files[@]} -gt 0 && -z "${input_files[-1]}" ]]; then
			unset 'input_files[-1]'
		fi

		if [[ ${#input_files[@]} -eq 0 ]]; then
			echo "No files selected via fzf for loading. Exiting." >&2
			exit 0
		fi

	elif [[ ${#temp_input_files[@]} -gt 0 ]]; then
		input_files=("${temp_input_files[@]}")
	else
		echo "No input file specified. Using default: '$DEFAULT_INPUT_FILE'"
		input_files=("$DEFAULT_INPUT_FILE")
	fi

	if [[ ${#input_files[@]} -eq 0 ]]; then
		echo "Error: No input files specified or selected for loading." >&2
		usage
	fi

elif [[ "$mode" == "dump" ]]; then
	output_file="${temp_output_file:-$DEFAULT_OUTPUT_FILE}"

	if [[ "$fzf_mode" -eq 1 ]]; then
		if ! command -v fzf &>/dev/null; then
			echo "Error: fzf is not installed." >&2
			echo "Please install fzf to use the -fzf option (e.g., brew install fzf, sudo apt-get install fzf)." >&2
			exit 1
		fi

		echo "Using fzf to select files for dumping... Use TAB to select multiple, ENTER to confirm."
		readarray -d $'\0' -t fzf_dump_selection_files < <(find . -type f -not -path '*/\.git/*' -not -path '*/node_modules/*' -print0 |
			grep -v -z "^./$output_file$" | # Exclude the output file path itself (null-aware grep)
			fzf --read0 --print0 --multi --cycle --exit-0 --prompt="Select file(s) to dump > ")
		fzf_status=$?

		if [[ "$fzf_status" -ne 0 ]]; then
			echo "File selection cancelled via fzf (exit code $fzf_status). Exiting." >&2
			exit 1
		fi

		for i in "${!fzf_dump_selection_files[@]}"; do
			fzf_dump_selection_files[$i]="${fzf_dump_selection_files[$i]%$'\n'}"
		done

		if [[ ${#fzf_dump_selection_files[@]} -gt 0 && -z "${fzf_dump_selection_files[-1]}" ]]; then
			unset 'fzf_dump_selection_files[-1]'
		fi

		if [[ ${#fzf_dump_selection_files[@]} -eq 0 ]]; then
			echo "No files selected via fzf for dumping. Exiting." >&2
			exit 0
		fi

	fi

fi

# --- Main Execution Block ---

if [[ "$mode" == "load" ]]; then

	echo "Starting file creation process from input file(s)..."
	echo "Input file(s) to load (${#input_files[@]}):"
	printf "  %s\n" "${input_files[@]}"
	for input_file in "${input_files[@]}"; do
		echo "--- Processing input file: '$input_file' ---"
		if [[ ! -f "$input_file" ]]; then
			echo "Error: Input file '$input_file' not found. Skipping." >&2
			continue
		fi

		current_file_being_written=""

		while IFS= read -r line || [[ -n "$line" ]]; do
			if [[ "$line" =~ $START_DELIM_PATTERN ]]; then
				current_file_path="${BASH_REMATCH[1]}"
				if [[ -z "${current_file_path// /}" ]]; then
					echo "Warning: Found empty or whitespace file path in START delimiter in '$input_file'. Skipping this block." >&2
					current_file_being_written="" # Ensure subsequent lines aren't written to a bad path
					continue
				fi

				current_file_being_written="$current_file_path"

				dir_path=$(dirname "$current_file_being_written")

				if [[ "$dir_path" != "." ]]; then
					if [[ ! -d "$dir_path" ]]; then
						mkdir -p "$dir_path"
						if [[ $? -eq 0 ]]; then
							echo "  Created directory: $dir_path"
							((created_dirs++))
						else
							echo "  Error creating directory: $dir_path from '$input_file'. Skipping file creation for '$current_file_being_written'." >&2
							# On directory creation failure, skip processing this file block
							current_file_being_written=""
							continue # Skip to the next line in the current input file
						fi
					fi
				fi

				if [[ -n "$current_file_being_written" ]]; then
					>"$current_file_being_written"
					echo "  Processing '$current_file_being_written'..."
				fi
				continue

			fi

			if [[ "$line" =~ $END_DELIM_PATTERN ]]; then
				if [[ -n "$current_file_being_written" && "${BASH_REMATCH[1]}" == "$current_file_being_written" ]]; then
					echo "  Finished writing '$current_file_being_written'."
					((written_files++))
					current_file_being_written=""
				else
					echo "Warning: Found END delimiter ('${BASH_REMATCH[1]}') without matching START or a filename mismatch in '$input_file'. Currently processing: '$current_file_being_written'. Line: '$line'" >&2
				fi
				continue
			fi

			if [[ -n "$current_file_being_written" ]]; then
				echo "$line" >>"$current_file_being_written"
			fi

		done <"$input_file"

		echo "--- Finished processing '$input_file' ---"
		echo ""

	done

	echo "-------------------------------------"
	echo "File creation process finished."
	echo "Input files processed: ${#input_files[@]}"
	echo "Directories created: $created_dirs"
	echo "Files written/overwritten: $written_files"
	echo "Please check the created files/directories in the current location ($(pwd))."

elif [[ "$mode" == "dump" ]]; then

	echo "Starting file dumping process from current directory ('.') to '$output_file'..."

	>"$output_file"

	declare -a files_to_dump

	if [[ "$fzf_mode" -eq 1 ]]; then
		files_to_dump=("${fzf_dump_selection_files[@]}")
		echo "Dumping selected files (${#files_to_dump[@]}):"
		printf "  %s\n" "${files_to_dump[@]}"
	else
		echo "Finding all files in '.' (excluding output file '$output_file')..."
		readarray -d $'\0' -t files_to_dump < <(find . -type f -not -path '*/\.git/*' -not -path '*/node_modules/*' -not -path '*/build/*' -not -path '*/dist/*' -not -name '*.png' -not -name "package-lock.json" -not -name '*.ico' -not -name '*.jpg' -not -name '*.jpeg' -not -name '*.gif' -not -name '*.db' -not -name '*.icon' -not -name '*.svg' -not -name '*.mp4' -not -name '*.mkv' -not -name '*.avi' -print0 | grep -v -z "^./$output_file$")

		for i in "${!files_to_dump[@]}"; do
			files_to_dump[$i]="${files_to_dump[$i]%$'\n'}"
		done

		if [[ ${#files_to_dump[@]} -gt 0 && -z "${files_to_dump[-1]}" ]]; then
			unset 'files_to_dump[-1]'
		fi

		if [[ ${#files_to_dump[@]} -eq 0 ]]; then
			echo "No files found to dump (excluding '$output_file')."
			echo "Output file '$output_file' created but empty."
			echo "-------------------------------------"
			echo "File dumping process finished."
			exit 0
		fi
		printf "Dumping all found files (%d).\n" ${#files_to_dump[@]}
	fi

	for file in "${files_to_dump[@]}"; do
		if [[ "$file" == "./$output_file" ]]; then
			echo "Warning: Attempted to dump the output file itself ('$file'). Skipping." >&2
			continue
		fi

		if [[ ! -f "$file" ]]; then
			echo "Warning: File to dump not found ('$file'). Skipping." >&2
			continue
		fi

		echo "==== START $file ====" >>"$output_file"

		cat "$file" >>"$output_file"

		echo "==== END $file ====" >>"$output_file"

		# echo "" >>"$output_file"

	done

	echo "-------------------------------------"
	echo "File dumping process finished."
	echo "Output written to '$output_file' in the current directory ($(pwd))."
	echo "Please check the file contents."

else
	echo "Internal Error: Invalid mode '$mode'." >&2
	exit 1
fi
==== END ./ld.sh ====
==== START ./package.json ====
{
  "name": "boon-front-end",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "serve:ssr:boon-front-end": "node dist/boon-front-end/server/server.mjs"
  },
  "prettier": {
    "overrides": [
      {
        "files": "*.html",
        "options": {
          "parser": "angular"
        }
      }
    ]
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^20.1.0",
    "@angular/common": "^20.0.0",
    "@angular/compiler": "^20.1.0",
    "@angular/core": "^20.0.0",
    "@angular/forms": "^20.0.0",
    "@angular/platform-browser": "^20.0.0",
    "@angular/platform-server": "^20.0.0",
    "@angular/router": "^20.0.0",
    "@angular/ssr": "^20.0.5",
    "@ngrx/signals": "20.0.0-beta.0",
    "@primeuix/themes": "^1.2.1",
    "@tailwindcss/forms": "^0.5.10",
    "@tailwindcss/postcss": "^4.1.11",
    "@tanstack/angular-query-experimental": "^5.83.0",
    "express": "^5.1.0",
    "postcss": "^8.5.6",
    "primeicons": "^7.0.0",
    "primeng": "^20.0.0-rc.1",
    "rxjs": "~7.8.0",
    "tailwindcss": "^4.1.11",
    "tslib": "^2.3.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@angular/build": "^20.0.5",
    "@angular/cli": "^20.0.5",
    "@angular/compiler-cli": "^20.0.0",
    "@types/express": "^5.0.1",
    "@types/jasmine": "~5.1.0",
    "@types/node": "^20.17.19",
    "@types/uuid": "^9.0.8",
    "jasmine-core": "~5.7.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "typescript": "~5.8.2"
  }
}
==== END ./package.json ====
==== START ./README.md ====
# Boon E-commerce Frontend

A modern Angular 20 e-commerce application built with TanStack Query, NgRx SignalStore, PrimeNG, and Tailwind CSS.

## 🚀 Features

- **Angular 20** with zoneless change detection for optimal performance
- **TanStack Query** for server state management and caching
- **NgRx SignalStore** for complex client-side state (checkout, filters)
- **Angular Signals** for component-specific UI state
- **PrimeNG** components with Tailwind CSS styling
- **Feature-based architecture** for scalable development
- **Accessibility** compliant with WCAG 2.2 guidelines
- **Responsive design** with mobile-first approach

## 📁 Project Structure

```
src/
├── app/
│   ├── core/                          # Global utilities and models
│   │   ├── guards/                    # Route guards (e.g., auth guard)
│   │   ├── interceptors/              # HTTP interceptors (e.g., auth token)
│   │   ├── models/                    # TypeScript interfaces
│   │   ├── services/                  # Global services
│   │   ├── constants/                 # App-wide constants
│   │   └── enums/                     # TypeScript enums
│   ├── features/                      # Feature modules
│   │   ├── products/                  # Product-related functionality
│   │   │   ├── components/            # Standalone components
│   │   │   ├── queries/               # TanStack Query logic
│   │   │   └── store/                 # NgRx SignalStore for product filters
│   │   ├── cart/                      # Cart-related functionality
│   │   ├── orders/                    # Order-related functionality
│   │   ├── user/                      # User-related functionality
│   │   └── payments/                  # Payment-related functionality
│   └── shared/                        # Shared utilities and components
│       ├── components/                # PrimeNG wrappers
│       ├── layouts/                   # Layout components
│       ├── pipes/                     # Custom pipes
│       └── utils/                     # Utility functions
├── assets/                            # Static assets
├── styles/                            # Global Tailwind CSS
└── environments/                      # Environment configs
```

## 🛠️ Technology Stack

### Core Framework

- **Angular 20** - Latest version with standalone components
- **TypeScript 5.5+** - Strict mode enabled
- **Zoneless Change Detection** - For better performance

### State Management

- **TanStack Query v5** - Server state management and caching
- **NgRx SignalStore v19.2.1** - Complex client-side state
- **Angular Signals** - Component-specific UI state

### UI/UX

- **PrimeNG v20** - UI component library
- **Tailwind CSS v4.1** - Utility-first CSS framework
- **Accessibility** - WCAG 2.2 AA compliance

### Development Tools

- **ESLint** - Code linting
- **Prettier** - Code formatting
- **Jest** - Unit testing
- **Cypress/Playwright** - E2E testing

## 🚀 Getting Started

### Prerequisites

- Node.js 18+
- npm or yarn
- Angular CLI 20

### Installation

1. **Clone the repository**

   ```bash
   git clone <repository-url>
   cd boon-front-end
   ```

2. **Install dependencies**

   ```bash
   npm install
   ```

3. **Install additional packages** (when needed)

   ```bash
   # TanStack Query
   npm install @tanstack/angular-query

   # NgRx SignalStore
   npm install @ngrx/signals

   # PrimeNG
   npm install primeng primeicons

   # Tailwind CSS
   npm install -D tailwindcss postcss autoprefixer
   ```

4. **Start development server**

   ```bash
   npm start
   ```

5. **Build for production**
   ```bash
   npm run build
   ```

## 📋 API Integration

The application integrates with a .NET e-commerce API with the following endpoints:

### Authentication (`/api/Authentication`)

- `POST /login` - User login
- `POST /register` - User registration
- `GET /emailExists` - Check email availability
- `GET /currentUser` - Get current user
- `GET /address` - Get user address
- `PUT /address` - Update user address

### Baskets (`/api/Baskets`)

- `GET /` - Get user basket
- `POST /` - Add item to basket
- `PUT /` - Update basket item
- `DELETE /` - Remove item from basket

### Orders (`/api/Orders`)

- `POST /` - Create order
- `GET /` - Get user orders
- `GET /deliveryMethods` - Get delivery methods

### Payments (`/api/Payments`)

- `POST /{basketId}` - Create payment intent
- `POST /WebHook` - Payment webhook

### Products (`/api/Products`)

- `GET /` - Get paginated products
- `GET /{id}` - Get single product
- `GET /brands` - Get product brands
- `GET /types` - Get product types

## 🏗️ Architecture Patterns

### State Management Strategy

- **TanStack Query**: Server state (products, cart, orders)
- **NgRx SignalStore**: Complex client state (checkout flow, filters)
- **Signals**: Component-specific UI state (loading, form state)

### Component Architecture

- **Standalone Components**: All components are standalone
- **Feature-based Structure**: Organized by business features
- **Shared Components**: Reusable UI components

### Error Handling

- **Global Error Interceptor**: HTTP error handling
- **Toast Notifications**: User feedback
- **Form Validation**: Client-side validation

## 🧪 Testing Strategy

### Unit Testing

- **Jest** for components, services, and utilities
- **Mock Query Client** for TanStack Query testing
- **Mock SignalStore** for NgRx SignalStore testing
- **Accessibility Testing** with axe-core

### Integration Testing

- Component interactions with TanStack Query
- NgRx SignalStore state changes and methods
- API integration with mock backends

### E2E Testing

- **Cypress/Playwright** for user journey testing
- Critical paths: login, add to cart, checkout
- Responsive design testing

## 📱 Responsive Design

The application follows a mobile-first approach with Tailwind CSS breakpoints:

- **Mobile**: Default styles
- **Tablet**: `sm:` prefix (640px+)
- **Desktop**: `md:` prefix (768px+)
- **Large Desktop**: `lg:` prefix (1024px+)

## ♿ Accessibility

- **WCAG 2.2 AA** compliance
- **ARIA attributes** for screen readers
- **Keyboard navigation** support
- **Focus management** for better UX
- **Color contrast** ratios maintained

## 🔧 Development Workflow

### Code Style

- **Angular Style Guide** compliance
- **ESLint** with `@angular-eslint` rules
- **Prettier** for consistent formatting
- **Conventional Commits** for git messages

### Git Workflow

- **GitFlow** branching strategy
- **Feature branches** for new development
- **Pull request reviews** with automated checks

### CI/CD Pipeline

- Automated testing and linting
- Build and deploy to staging
- Accessibility testing with axe-core

## 📦 Build Configuration

### Development

```bash
npm start          # Start dev server
npm run build      # Build for production
npm run test       # Run unit tests
npm run e2e        # Run E2E tests
npm run lint       # Run ESLint
npm run format     # Run Prettier
```

### Environment Configuration

- `environment.ts` - Development settings
- `environment.prod.ts` - Production settings

## 🚀 Performance Optimization

- **Zoneless Change Detection** for better performance
- **Lazy Loading** for route-level and component-level code splitting
- **TanStack Query Caching** with appropriate stale times
- **Image Optimization** with lazy loading
- **Bundle Splitting** by feature and vendor libraries

## 🔒 Security

- **JWT Token** authentication
- **HTTP Interceptors** for secure API calls
- **Input Sanitization** to prevent XSS
- **Content Security Policy** headers
- **HTTPS** enforcement in production

## 📈 Monitoring & Analytics

- **Error Tracking** with global error interceptor
- **Performance Monitoring** with Angular DevTools
- **User Analytics** (to be implemented)
- **A/B Testing** capabilities (to be implemented)

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'feat: add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🆘 Support

For support and questions:

- Create an issue in the repository
- Check the documentation
- Review the code examples

---

**Built with ❤️ using Angular 20, TanStack Query, NgRx SignalStore, and PrimeNG**
==== END ./README.md ====
==== START ./src/app/app.config.server.ts ====
import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';
import { provideServerRendering, withRoutes } from '@angular/ssr';
import { appConfig } from './app.config';
import { serverRoutes } from './app.routes.server';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(withRoutes(serverRoutes))
  ]
};

export const config = mergeApplicationConfig(appConfig, serverConfig);
==== END ./src/app/app.config.server.ts ====
==== START ./src/app/app.config.ts ====
import {
  ApplicationConfig,
  provideBrowserGlobalErrorListeners,
  provideZonelessChangeDetection,
  InjectionToken,
} from '@angular/core';
import { provideRouter, withComponentInputBinding } from '@angular/router';
import {
  provideHttpClient,
  withFetch,
  withInterceptors,
} from '@angular/common/http';

import { routes } from './app.routes';
import {
  provideClientHydration,
  withEventReplay,
} from '@angular/platform-browser';
import { providePrimeNG } from 'primeng/config';
import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
import {
  provideQueryClient,
  QueryClient,
} from '@tanstack/angular-query-experimental';
import Aura from '@primeuix/themes/aura';
import { environment } from '../environments/environment';
import { ConfirmationService, MessageService } from 'primeng/api';
import { authInterceptor } from '@core/interceptors/auth.interceptor';
import { errorInterceptor } from '@core/interceptors/error.interceptor';

export const API_URL = new InjectionToken<string>('API_URL');
export const STRIPE_PUBLISHABLE_KEY = new InjectionToken<string>(
  'STRIPE_PUBLISHABLE_KEY'
);
export const APP_NAME = new InjectionToken<string>('APP_NAME');
export const APP_VERSION = new InjectionToken<string>('APP_VERSION');
export const DEBUG = new InjectionToken<boolean>('DEBUG');

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,
      gcTime: 1000 * 60 * 10,

      retry: 3,
    },
  },
});
export const appConfig: ApplicationConfig = {
  providers: [
    provideAnimationsAsync(),
    providePrimeNG({
      ripple: true,
      theme: {
        preset: Aura,
      },
    }),
    provideBrowserGlobalErrorListeners(),
    provideZonelessChangeDetection(),
    provideRouter(routes, withComponentInputBinding()),
    provideHttpClient(
      withFetch(),
      withInterceptors([authInterceptor, errorInterceptor])
    ),
    MessageService,
    ConfirmationService,
    provideQueryClient(queryClient),
    provideClientHydration(withEventReplay()),
    { provide: API_URL, useValue: environment.apiUrl },
    {
      provide: STRIPE_PUBLISHABLE_KEY,
      useValue: environment.stripePublishableKey,
    },
    { provide: APP_NAME, useValue: environment.appName },
    { provide: APP_VERSION, useValue: environment.version },
    { provide: DEBUG, useValue: environment.debug },
  ],
};
==== END ./src/app/app.config.ts ====
==== START ./src/app/app.html ====
<app-navbar></app-navbar>
<main class="flex-grow w-full max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8">
  <router-outlet></router-outlet>
</main>
<app-footer></app-footer>

<!-- Global PrimeNG Overlays -->
<p-toast></p-toast>
<p-confirmDialog
  [style]="{ width: '50vw' }"
  [breakpoints]="{ '1199px': '75vw', '575px': '90vw' }"
  acceptButtonStyleClass="p-button-danger"
  rejectButtonStyleClass="p-button-text"
></p-confirmDialog>
==== END ./src/app/app.html ====
==== START ./src/app/app.routes.server.ts ====
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: '**',
    renderMode: RenderMode.Prerender
  }
];
==== END ./src/app/app.routes.server.ts ====
==== START ./src/app/app.routes.ts ====
import { Routes } from '@angular/router';
import { NotFoundComponent } from './shared/components/not-found/not-found.component';
import { authGuard } from './core/guards/auth.guard';

export const routes: Routes = [
  { path: '', redirectTo: 'landing', pathMatch: 'full' },
  {
    path: 'landing',
    loadComponent: () =>
      import(
        './features/landing/components/landing-page/landing-page.component'
      ).then((m) => m.LandingPageComponent),
  },
  {
    path: 'products',
    children: [
      {
        path: '',
        loadComponent: () =>
          import(
            './features/products/components/product-list/product-list.component'
          ).then((m) => m.ProductListComponent),
      },
      {
        path: ':id',
        loadComponent: () =>
          import(
            './features/products/components/product-detail/product-detail.component'
          ).then((m) => m.ProductDetailComponent),
      },
    ],
  },
  {
    path: 'cart',
    canActivate: [authGuard],
    loadComponent: () =>
      import('./features/cart/components/cart-list/cart-list.component').then(
        (m) => m.CartListComponent
      ),
  },
  {
    path: 'orders',
    canActivate: [authGuard],
    children: [
      {
        path: '',
        loadComponent: () =>
          import(
            './features/orders/components/order-list/order-list.component'
          ).then((m) => m.OrderListComponent),
      },
      {
        path: 'checkout',
        loadComponent: () =>
          import(
            './features/orders/components/checkout/checkout.component'
          ).then((m) => m.CheckoutComponent),
      },
    ],
  },
  {
    path: 'user',
    children: [
      {
        path: 'login',
        loadComponent: () =>
          import('./features/user/components/login/login.component').then(
            (m) => m.LoginComponent
          ),
      },
      {
        path: 'register',
        loadComponent: () =>
          import('./features/user/components/register/register.component').then(
            (m) => m.RegisterComponent
          ),
      },
      {
        path: 'profile',
        canActivate: [authGuard],
        loadComponent: () =>
          import('./features/user/components/profile/profile.component').then(
            (m) => m.ProfileComponent
          ),
      },
    ],
  },
  {
    path: 'payments',
    canActivate: [authGuard],
    loadComponent: () =>
      import('./features/payments/components/payment/payment.component').then(
        (m) => m.PaymentComponent
      ),
  },
  {
    path: '**',
    loadComponent: () =>
      import('./shared/components/not-found/not-found.component').then(
        (m) => m.NotFoundComponent
      ),
  },
];
==== END ./src/app/app.routes.ts ====
==== START ./src/app/app.scss ====
/* App-level styles */
:host {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  background-color: #f8fafc; /* gray-50 */
}

/* Ensure proper layout with navbar and footer */
app-navbar {
  position: sticky;
  top: 0;
  z-index: 1020; /* Higher than most elements */
}

main {
  flex: 1 0 auto;
}

app-footer {
  margin-top: auto;
}==== END ./src/app/app.scss ====
==== START ./src/app/app.spec.ts ====
import { provideZonelessChangeDetection } from '@angular/core';
import { TestBed } from '@angular/core/testing';
import { App } from './app';

describe('App', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [App],
      providers: [provideZonelessChangeDetection()]
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(App);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(App);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, boon-front-end');
  });
});
==== END ./src/app/app.spec.ts ====
==== START ./src/app/app.ts ====
import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { NavbarComponent } from './shared/components/navbar/navbar.component';
import { FooterComponent } from './shared/components/footer/footer.component';
import { ToastModule } from 'primeng/toast';
import { ConfirmDialogModule } from 'primeng/confirmdialog';

@Component({
  selector: 'app-root',
  imports: [
    RouterOutlet,
    NavbarComponent,
    FooterComponent,
    ToastModule,
    ConfirmDialogModule,
  ],
  templateUrl: './app.html',
  styleUrl: './app.scss',
})
export class App {
  protected title = 'boon-front-end';
}
==== END ./src/app/app.ts ====
==== START ./src/app/core/constants/api-endpoints.ts ====
export const API_ENDPOINTS = {
  // Authentication
  AUTH: {
    LOGIN: '/api/Authentication/login',
    REGISTER: '/api/Authentication/register',
    EMAIL_CHECK: '/api/Authentication/emailExists',
    CURRENT_USER: '/api/Authentication/currentUser',
    ADDRESS: '/api/Authentication/address',
  },

  // Baskets (Cart)
  BASKETS: {
    GET: '/api/Baskets',
    ADD_ITEM: '/api/Baskets',
    UPDATE_ITEM: '/api/Baskets',
    REMOVE_ITEM: '/api/Baskets',
  },

  // Orders
  ORDERS: {
    CREATE: '/api/Orders',
    GET_ORDERS: '/api/Orders',
    DELIVERY_METHODS: '/api/Orders/deliveryMethods',
  },

  // Payments
  PAYMENTS: {
    CREATE_PAYMENT_INTENT: '/api/Payments',
    WEBHOOK: '/api/Payments/WebHook',
  },

  // Products
  PRODUCTS: {
    GET_PRODUCTS: '/api/Products',
    GET_PRODUCT: (id: number) => `/api/Products/${id}`,
    GET_BRANDS: '/api/Products/brands',
    GET_TYPES: '/api/Products/types',
  },
} as const;
==== END ./src/app/core/constants/api-endpoints.ts ====
==== START ./src/app/core/constants/app-constants.ts ====
export const APP_CONSTANTS = {
  // Pagination
  DEFAULT_PAGE_SIZE: 6,
  MAX_PAGE_SIZE: 50,

  // Cart
  MAX_QUANTITY: 99,
  MIN_QUANTITY: 1,

  // Validation
  EMAIL_REGEX: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  PASSWORD_MIN_LENGTH: 6,

  // UI
  TOAST_DURATION: 3000,
  DEBOUNCE_DELAY: 300,

  // Storage Keys
  TOKEN_KEY: 'token',
  USER_KEY: 'user',
  BASKET_ID_KEY: 'basketId',

  // Sort Options
  SORT_OPTIONS: {
    NAME_ASC: 'name',
    NAME_DESC: 'nameDesc',
    PRICE_ASC: 'price',
    PRICE_DESC: 'priceDesc',
  },

  // Order Status
  ORDER_STATUS: {
    PENDING: 'Pending',
    PAYMENT_RECEIVED: 'PaymentReceived',
    PAYMENT_FAILED: 'PaymentFailed',
    SHIPPED: 'Shipped',
    DELIVERED: 'Delivered',
  },
} as const;
==== END ./src/app/core/constants/app-constants.ts ====
==== START ./src/app/core/constants/storage-keys.ts ====
export const STORAGE_KEYS = {
  // Authentication
  AUTH_TOKEN: 'auth_token',
  CURRENT_USER: 'current_user',
  REFRESH_TOKEN: 'refresh_token',

  // Cart
  BASKET_ID: 'basket_id',
  CART_ITEMS: 'cart_items',

  // User Preferences
  USER_PREFERENCES: 'user_preferences',
  THEME_PREFERENCE: 'theme_preference',
  LANGUAGE_PREFERENCE: 'language_preference',

  // Filters
  PRODUCT_FILTERS: 'product_filters',
  SEARCH_HISTORY: 'search_history',

  // Checkout
  CHECKOUT_ADDRESS: 'checkout_address',
  SELECTED_DELIVERY_METHOD: 'selected_delivery_method',

  // App State
  LAST_VISITED_PAGE: 'last_visited_page',
  SESSION_ID: 'session_id',
} as const;
==== END ./src/app/core/constants/storage-keys.ts ====
==== START ./src/app/core/enums/order-status.enum.ts ====
export enum OrderStatus {
  PENDING = 'Pending',
  PAYMENT_RECEIVED = 'PaymentReceived',
  PAYMENT_FAILED = 'PaymentFailed',
  SHIPPED = 'Shipped',
  DELIVERED = 'Delivered',
  CANCELLED = 'Cancelled',
}

export const ORDER_STATUS_LABELS: Record<OrderStatus, string> = {
  [OrderStatus.PENDING]: 'Pending',
  [OrderStatus.PAYMENT_RECEIVED]: 'Payment Received',
  [OrderStatus.PAYMENT_FAILED]: 'Payment Failed',
  [OrderStatus.SHIPPED]: 'Shipped',
  [OrderStatus.DELIVERED]: 'Delivered',
  [OrderStatus.CANCELLED]: 'Cancelled',
};

export const ORDER_STATUS_COLORS: Record<OrderStatus, string> = {
  [OrderStatus.PENDING]: 'bg-yellow-100 text-yellow-800',
  [OrderStatus.PAYMENT_RECEIVED]: 'bg-blue-100 text-blue-800',
  [OrderStatus.PAYMENT_FAILED]: 'bg-red-100 text-red-800',
  [OrderStatus.SHIPPED]: 'bg-purple-100 text-purple-800',
  [OrderStatus.DELIVERED]: 'bg-green-100 text-green-800',
  [OrderStatus.CANCELLED]: 'bg-gray-100 text-gray-800',
};
==== END ./src/app/core/enums/order-status.enum.ts ====
==== START ./src/app/core/enums/payment-status.enum.ts ====
export enum PaymentStatus {
  PENDING = 'Pending',
  PROCESSING = 'Processing',
  SUCCEEDED = 'Succeeded',
  FAILED = 'Failed',
  CANCELLED = 'Cancelled',
  REFUNDED = 'Refunded',
  PARTIALLY_REFUNDED = 'PartiallyRefunded',
}

export const PAYMENT_STATUS_LABELS: Record<PaymentStatus, string> = {
  [PaymentStatus.PENDING]: 'Pending',
  [PaymentStatus.PROCESSING]: 'Processing',
  [PaymentStatus.SUCCEEDED]: 'Succeeded',
  [PaymentStatus.FAILED]: 'Failed',
  [PaymentStatus.CANCELLED]: 'Cancelled',
  [PaymentStatus.REFUNDED]: 'Refunded',
  [PaymentStatus.PARTIALLY_REFUNDED]: 'Partially Refunded',
};

export const PAYMENT_STATUS_COLORS: Record<PaymentStatus, string> = {
  [PaymentStatus.PENDING]: 'bg-yellow-100 text-yellow-800',
  [PaymentStatus.PROCESSING]: 'bg-blue-100 text-blue-800',
  [PaymentStatus.SUCCEEDED]: 'bg-green-100 text-green-800',
  [PaymentStatus.FAILED]: 'bg-red-100 text-red-800',
  [PaymentStatus.CANCELLED]: 'bg-gray-100 text-gray-800',
  [PaymentStatus.REFUNDED]: 'bg-purple-100 text-purple-800',
  [PaymentStatus.PARTIALLY_REFUNDED]: 'bg-orange-100 text-orange-800',
};
==== END ./src/app/core/enums/payment-status.enum.ts ====
==== START ./src/app/core/enums/user-roles.enum.ts ====
export enum UserRole {
  CUSTOMER = 'Customer',
  ADMIN = 'Admin',
  MODERATOR = 'Moderator',
}

export const USER_ROLE_LABELS: Record<UserRole, string> = {
  [UserRole.CUSTOMER]: 'Customer',
  [UserRole.ADMIN]: 'Administrator',
  [UserRole.MODERATOR]: 'Moderator',
};

export const USER_ROLE_PERMISSIONS: Record<UserRole, string[]> = {
  [UserRole.CUSTOMER]: [
    'view_products',
    'add_to_cart',
    'place_orders',
    'view_own_orders',
    'update_profile',
  ],
  [UserRole.ADMIN]: [
    'view_products',
    'manage_products',
    'manage_orders',
    'manage_users',
    'view_analytics',
    'manage_system',
  ],
  [UserRole.MODERATOR]: [
    'view_products',
    'manage_products',
    'view_orders',
    'manage_orders',
  ],
};
==== END ./src/app/core/enums/user-roles.enum.ts ====
==== START ./src/app/core/guards/auth.guard.ts ====
import { inject } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService } from '../services/auth.service';

export function authGuard() {
  const authService = inject(AuthService);
  const router = inject(Router);
  if (authService.isLoggedIn()) {
    return true;
  }
  router.navigate(['/user/login']);
  return false;
}
==== END ./src/app/core/guards/auth.guard.ts ====
==== START ./src/app/core/interceptors/auth.interceptor.ts ====
import { HttpRequest, HttpHandlerFn, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';
import { STORAGE_KEYS } from '../constants/storage-keys';
import { StorageUtils } from '@shared/utils/storage.utils';

export function authInterceptor(
  request: HttpRequest<unknown>,
  next: HttpHandlerFn
): Observable<HttpEvent<unknown>> {
  const token = StorageUtils.getLocalItem<string>(STORAGE_KEYS.AUTH_TOKEN);

  // Debug logging for authentication endpoints
  if (request.url.includes('/api/Authentication/')) {
    console.log('AuthInterceptor - URL:', request.url);
    console.log('AuthInterceptor - Token present:', !!token);
    if (token) {
      console.log('AuthInterceptor - Token length:', token.length);
      console.log(
        'AuthInterceptor - Token starts with:',
        token.substring(0, 20) + '...'
      );
    }
  }

  if (token) {
    request = request.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`,
      },
    });
  }

  return next(request);
}
==== END ./src/app/core/interceptors/auth.interceptor.ts ====
==== START ./src/app/core/interceptors/error.interceptor.ts ====
import {
  HttpRequest,
  HttpHandlerFn,
  HttpEvent,
  HttpErrorResponse,
} from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { inject } from '@angular/core';
import { Router } from '@angular/router';
import { ToastService } from '../services/toast.service';
import { STORAGE_KEYS } from '../constants/storage-keys';

export function errorInterceptor(
  request: HttpRequest<unknown>,
  next: HttpHandlerFn
): Observable<HttpEvent<unknown>> {
  const router = inject(Router);
  const toastService = inject(ToastService);

  return next(request).pipe(
    catchError((error: HttpErrorResponse) => {
      handleError(error, router, toastService);
      return throwError(() => error);
    })
  );
}

function handleError(
  error: HttpErrorResponse,
  router: Router,
  toastService: ToastService
): void {
  switch (error.status) {
    case 401:
      handleUnauthorized(router, toastService);
      break;
    case 403:
      handleForbidden(toastService);
      break;
    case 404:
      handleNotFound(toastService);
      break;
    case 422:
      handleValidationError(error, toastService);
      break;
    case 500:
      handleServerError(toastService);
      break;
    default:
      handleGenericError(error, toastService);
      break;
  }
}

function handleUnauthorized(router: Router, toastService: ToastService): void {
  localStorage.removeItem(STORAGE_KEYS.AUTH_TOKEN);
  localStorage.removeItem(STORAGE_KEYS.CURRENT_USER);
  toastService.showError('Authentication Error', 'Please log in again.');
  const currentUrl = router.url;
  if (currentUrl !== '/user/login' && currentUrl !== '/user/register') {
    router.navigate(['/user/login']);
  }
}

function handleForbidden(toastService: ToastService): void {
  toastService.showError(
    'Access Denied',
    'You do not have permission to perform this action.'
  );
}

function handleNotFound(toastService: ToastService): void {
  toastService.showError('Not Found', 'The requested resource was not found.');
}

function handleValidationError(
  error: HttpErrorResponse,
  toastService: ToastService
): void {
  const validationErrors = error.error?.errors;
  if (validationErrors) {
    const errorMessages = Object.values(validationErrors).flat() as string[];
    toastService.showValidationError(errorMessages);
  } else {
    toastService.showError(
      'Validation Error',
      'Please check your input and try again.'
    );
  }
}

function handleServerError(toastService: ToastService): void {
  toastService.showError(
    'Server Error',
    'An internal server error occurred. Please try again later.'
  );
}

function handleGenericError(
  error: HttpErrorResponse,
  toastService: ToastService
): void {
  if (error.status === 0) {
    toastService.showNetworkError();
  } else {
    const message = error.error?.message || 'An unexpected error occurred';
    toastService.showError('Error', message);
  }
}
==== END ./src/app/core/interceptors/error.interceptor.ts ====
==== START ./src/app/core/models/address.model.ts ====
export interface AddressDTO {
  fullName: string;
  address1: string;
  address2?: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}
==== END ./src/app/core/models/address.model.ts ====
==== START ./src/app/core/models/basket.model.ts ====
export interface BasketDTO {
  id: string;
  items: BasketItemDTO[];
  paymentIntentId?: string;
  clientSecret?: string;
  deliveryMethodId?: number;
  shippingPrice: number;
}

export interface BasketItemDTO {
  id: number; // Product ID
  productName: string;
  pictureUrl: string;
  price: number;
  quantity: number;
}

export interface AddItemRequest {
  productId: number;
  quantity: number;
}

export interface UpdateItemRequest {
  id: number;
  quantity: number;
}

export interface RemoveItemRequest {
  id: number;
}
==== END ./src/app/core/models/basket.model.ts ====
==== START ./src/app/core/models/error.model.ts ====
export interface ErrorDetails {
  statusCode: number;
  errorMessage: string;
  errors?: string[];
}

export interface ValidationErrorResponse {
  statusCode: number;
  errorMessage: string;
  validationErrors: ValidationError[];
}

export interface ValidationError {
  field: string;
  errors: string[];
}

export interface ApiError {
  code: string;
  message: string;
  details?: any;
}

export interface NetworkError {
  status: number;
  statusText: string;
  message: string;
}
==== END ./src/app/core/models/error.model.ts ====
==== START ./src/app/core/models/filter.model.ts ====
import { ProductQueryParameters } from './product.model';

export interface ProductFilter {
  brandId?: number;
  typeId?: number;
  sort?: string;
  search?: string;
  pageIndex?: number;
  pageSize?: number;
}

export interface FilterState {
  filters: ProductQueryParameters;
  isLoading: boolean;
  error: string | null;
}
==== END ./src/app/core/models/filter.model.ts ====
==== START ./src/app/core/models/index.ts ====
// Basket Models
export * from './basket.model';

// Product Models
export * from './product.model';

// Order Models
export * from './order.model';

// User Models
export * from './user.model';

// Address Models
export * from './address.model';

// Error Models
export * from './error.model';

// Filter Models
export * from './filter.model';
==== END ./src/app/core/models/index.ts ====
==== START ./src/app/core/models/order.model.ts ====
import { AddressDTO } from './address.model';

export interface OrderRequest {
  basketId: string;
  shipToAddress: AddressDTO;
  deliveryMethodId: number;
}

export interface OrderResponse {
  id: string; // Guid as string
  buyerEmail: string;
  orderDate: string; // ISO date string
  shipToAddress: AddressDTO;
  deliveryMethod: string;
  items: OrderItemDTO[];
  status: string;
  paymentIntentId: string;
  subtotal: number;
  total: number;
  deliveryCost: number;
}

export interface OrderItemDTO {
  productId: number;
  name: string;
  pictureUrl: string;
  price: number;
  quantity: number;
}

export interface DeliveryMethodResponse {
  id: number;
  shortName: string;
  deliveryTime: string;
  description: string;
  price: number;
}

export interface OrderListResponse {
  data: OrderResponse[];
  count: number;
  pageIndex: number;
  pageSize: number;
  totalPages: number;
}
==== END ./src/app/core/models/order.model.ts ====
==== START ./src/app/core/models/product.model.ts ====
export interface ProductResponse {
  id: number;
  name: string;
  description: string;
  pictureUrl: string;
  price: number;
  productType: string;
  productBrand: string;
}

export interface ProductQueryParameters {
  brandId?: number;
  typeId?: number;
  sort: ProductSortingOptions;
  search?: string;
  pageIndex: number;
  pageSize: number;
}

export enum ProductSortingOptions {
  NameAsc = 'NameAsc',
  NameDesc = 'NameDesc',
  PriceAsc = 'PriceAsc',
  PriceDesc = 'PriceDesc',
}

export interface PaginatedResponse<T> {
  pageIndex: number;
  pageSize: number;
  count: number;
  data: T[];
}

export interface BrandResponse {
  id: number;
  name: string;
}

export interface TypeResponse {
  id: number;
  name: string;
}
==== END ./src/app/core/models/product.model.ts ====
==== START ./src/app/core/models/user.model.ts ====
export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  displayName: string;
  userName: string;
  phoneNumber?: string;
}

export interface UserResponse {
  email: string;
  displayName: string;
  token: string;
}

export interface EmailCheckRequest {
  email: string;
}

export interface EmailCheckResponse {
  emailExists: boolean;
}

export interface CurrentUserResponse {
  email: string;
  displayName: string;
}
==== END ./src/app/core/models/user.model.ts ====
==== START ./src/app/core/services/auth.service.ts ====
import { Injectable, signal } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import { BehaviorSubject, Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { environment } from '../../../environments/environment';
import { API_ENDPOINTS } from '../constants/api-endpoints';
import { STORAGE_KEYS } from '../constants/storage-keys';
import {
  UserResponse,
  LoginRequest,
  RegisterRequest,
  CurrentUserResponse,
  EmailCheckRequest,
  EmailCheckResponse,
} from '../models/user.model';
import { AddressDTO } from '../models/address.model';
import { StorageUtils } from '@shared/utils/storage.utils';

@Injectable({
  providedIn: 'root',
})
export class AuthService {
  private currentUserSource = new BehaviorSubject<UserResponse | null>(null);
  public currentUser$ = this.currentUserSource.asObservable();

  // Signals for component state
  public isAuthenticated = signal(false);
  public isLoading = signal(false);

  constructor(private http: HttpClient, private router: Router) {
    this.loadCurrentUser();
  }

  setAuthState(user: UserResponse): void {
    this.setCurrentUser(user);
  }

  login(loginRequest: LoginRequest): Observable<UserResponse> {
    this.isLoading.set(true);
    return this.http
      .post<UserResponse>(
        `${environment.apiUrl}${API_ENDPOINTS.AUTH.LOGIN}`,
        loginRequest
      )
      .pipe(
        map((response: UserResponse) => {
          this.setCurrentUser(response);
          this.isLoading.set(false);
          return response;
        })
      );
  }

  register(registerRequest: RegisterRequest): Observable<UserResponse> {
    this.isLoading.set(true);
    return this.http
      .post<UserResponse>(
        `${environment.apiUrl}${API_ENDPOINTS.AUTH.REGISTER}`,
        registerRequest
      )
      .pipe(
        map((response: UserResponse) => {
          this.setCurrentUser(response);
          this.isLoading.set(false);
          return response;
        })
      );
  }

  logout(): void {
    StorageUtils.removeLocalItem(STORAGE_KEYS.AUTH_TOKEN);
    StorageUtils.removeLocalItem(STORAGE_KEYS.CURRENT_USER);
    this.currentUserSource.next(null);
    this.isAuthenticated.set(false);
    this.router.navigate(['/']);
  }

  checkEmailExists(email: string): Observable<EmailCheckResponse> {
    const request: EmailCheckRequest = { email };
    return this.http.get<EmailCheckResponse>(
      `${environment.apiUrl}${API_ENDPOINTS.AUTH.EMAIL_CHECK}`,
      {
        params: { email },
      }
    );
  }

  getCurrentUser(): Observable<CurrentUserResponse> {
    return this.http.get<CurrentUserResponse>(
      `${environment.apiUrl}${API_ENDPOINTS.AUTH.CURRENT_USER}`
    );
  }

  getUserAddress(): Observable<AddressDTO> {
    return this.http.get<AddressDTO>(
      `${environment.apiUrl}${API_ENDPOINTS.AUTH.ADDRESS}`
    );
  }

  updateUserAddress(address: AddressDTO): Observable<AddressDTO> {
    return this.http.put<AddressDTO>(
      `${environment.apiUrl}${API_ENDPOINTS.AUTH.ADDRESS}`,
      address
    );
  }

  private setCurrentUser(user: UserResponse): void {
    StorageUtils.setLocalItem(STORAGE_KEYS.AUTH_TOKEN, user.token);
    StorageUtils.setLocalItem(STORAGE_KEYS.CURRENT_USER, user);
    this.currentUserSource.next(user);
    this.isAuthenticated.set(true);
  }

  private loadCurrentUser(): void {
    const token = StorageUtils.getLocalItem<string>(STORAGE_KEYS.AUTH_TOKEN);
    const user = StorageUtils.getLocalItem<UserResponse>(
      STORAGE_KEYS.CURRENT_USER
    );

    if (token && user) {
      this.currentUserSource.next(user);
      this.isAuthenticated.set(true);
    }
  }

  getToken(): string | null {
    return StorageUtils.getLocalItem<string>(STORAGE_KEYS.AUTH_TOKEN);
  }

  isLoggedIn(): boolean {
    return !!this.getToken();
  }
}
==== END ./src/app/core/services/auth.service.ts ====
==== START ./src/app/core/services/toast.service.ts ====
import { Injectable, signal } from '@angular/core';
import { MessageService } from 'primeng/api';

export type ToastSeverity = 'success' | 'error' | 'warn' | 'info';

export interface ToastMessage {
  severity: ToastSeverity;
  summary: string;
  detail: string;
  key?: string;
  life?: number;
}

@Injectable({
  providedIn: 'root',
})
export class ToastService {
  public isVisible = signal(false);

  constructor(private messageService: MessageService) {}

  showSuccess(summary: string, detail: string, key: string = 'global'): void {
    this.showMessage({
      severity: 'success',
      summary,
      detail,
      key,
      life: 3000,
    });
  }

  showError(summary: string, detail: string, key: string = 'global'): void {
    this.showMessage({
      severity: 'error',
      summary,
      detail,
      key,
      life: 5000,
    });
  }

  showWarning(summary: string, detail: string, key: string = 'global'): void {
    this.showMessage({
      severity: 'warn',
      summary,
      detail,
      key,
      life: 4000,
    });
  }

  showInfo(summary: string, detail: string, key: string = 'global'): void {
    this.showMessage({
      severity: 'info',
      summary,
      detail,
      key,
      life: 3000,
    });
  }

  private showMessage(message: ToastMessage): void {
    this.messageService.add(message);
    this.isVisible.set(true);
  }

  clear(key?: string): void {
    this.messageService.clear(key);
    this.isVisible.set(false);
  }

  // Convenience methods for common scenarios
  showApiError(error: any, context: string = 'Operation'): void {
    const message = error?.message || 'An unexpected error occurred';
    this.showError(`${context} Failed`, message);
  }

  showNetworkError(): void {
    this.showError(
      'Network Error',
      'Please check your internet connection and try again.'
    );
  }

  showValidationError(errors: string[]): void {
    const message = errors.join(', ');
    this.showError('Validation Error', message);
  }

  showLoadingMessage(message: string = 'Loading...'): void {
    this.showInfo('Please Wait', message);
  }
}
==== END ./src/app/core/services/toast.service.ts ====
==== START ./src/app/features/cart/components/cart-list/cart-list.component.html ====
<div class="container mx-auto py-8">
  <!-- Loading State -->
  @if (basketQuery.isPending()) {
  <div class="flex justify-center items-center h-96">
    <p-progressSpinner
      aria-label="Loading cart"
      styleClass="w-12 h-12"
    ></p-progressSpinner>
  </div>
  }

  <!-- Error State -->
  @else if (basketQuery.error()) {
  <div class="text-center py-12">
    <p-message
      severity="error"
      text="We couldn't load your cart. Please try again later."
    ></p-message>
  </div>
  }

  <!-- Empty Cart State -->
  @else if (!basketQuery.data()?.items || basketQuery.data()?.items?.length ===
  0) {
  <div class="text-center py-20 bg-white rounded-2xl shadow-soft">
    <i class="pi pi-cart-plus text-7xl text-gray-400 mb-6"></i>
    <h2 class="text-3xl font-bold text-gray-800 mb-2">Your Cart is Empty</h2>
    <p class="text-gray-600 mb-8">
      Looks like you haven't added anything to your cart yet.
    </p>
    <p-button
      label="Start Shopping"
      icon="pi pi-arrow-right"
      iconPos="right"
      routerLink="/products"
      size="large"
    ></p-button>
  </div>
  }

  <!-- Cart with Items -->
  @else {
  <div class="grid lg:grid-cols-3 gap-8 items-start">
    <!-- Cart Items Column -->
    <div class="lg:col-span-2 space-y-4">
      <div class="flex justify-between items-baseline mb-4">
        <h1 class="text-3xl font-bold text-gray-800">Your Cart</h1>
        <p-button
          label="Clear Cart"
          severity="danger"
          [text]="true"
          (click)="clearCart()"
          [loading]="deleteBasketMutation.isPending()"
        ></p-button>
      </div>

      @for (item of basketQuery.data()?.items; track item.id) {
      <div
        class="flex items-center gap-4 p-4 bg-white rounded-lg shadow-soft transition-shadow hover:shadow-medium"
      >
        <img
          [src]="item.pictureUrl"
          [alt]="item.productName"
          class="w-24 h-24 object-cover rounded-md flex-shrink-0"
        />
        <div class="flex-grow">
          <h3 class="font-semibold text-lg text-gray-800">
            {{ item.productName }}
          </h3>
          <p class="text-gray-600">{{ item.price | currency }}</p>
        </div>
        <div class="flex items-center gap-4">
          <p-inputNumber
            [(ngModel)]="item.quantity"
            [min]="1"
            [max]="99"
            [showButtons]="true"
            buttonLayout="horizontal"
            spinnerMode="horizontal"
            inputId="horizontal_{{ item.id }}"
            decrementButtonClass="p-button-secondary"
            incrementButtonClass="p-button-secondary"
            incrementButtonIcon="pi pi-plus"
            decrementButtonIcon="pi pi-minus"
            [disabled]="updatingItem() === item.id"
            (onInput)="updateQuantity(item, $event.value || 1)"
            styleClass="w-32"
          ></p-inputNumber>
          <p class="font-bold text-lg w-24 text-right">
            {{ item.price * item.quantity | currency }}
          </p>
          <p-button
            icon="pi pi-trash"
            severity="danger"
            [rounded]="true"
            [text]="true"
            (onClick)="removeItem(item)"
            pTooltip="Remove item"
            tooltipPosition="top"
            [disabled]="updatingItem() === item.id"
          ></p-button>
        </div>
      </div>
      }
    </div>

    <!-- Order Summary Column -->
    <div class="lg:col-span-1 sticky top-24">
      <p-card header="Order Summary" styleClass="shadow-medium">
        <div class="space-y-4">
          <div class="flex justify-between text-lg">
            <span>Subtotal</span>
            <span class="font-semibold">{{ getSubtotal() | currency }}</span>
          </div>
          <div class="flex justify-between text-lg">
            <span>Shipping</span>
            <span class="font-semibold">{{
              basketQuery.data()?.shippingPrice | currency
            }}</span>
          </div>
          <hr class="my-2" />
          <div class="flex justify-between text-2xl font-bold">
            <span>Total</span>
            <span>{{ getTotalPrice() | currency }}</span>
          </div>
        </div>
        <ng-template pTemplate="footer">
          <p-button
            label="Proceed to Checkout"
            icon="pi pi-lock"
            styleClass="w-full"
            size="large"
            routerLink="/orders/checkout"
            [disabled]="deleteBasketMutation.isPending()"
          ></p-button>
        </ng-template>
      </p-card>
    </div>
  </div>
  }
</div>
==== END ./src/app/features/cart/components/cart-list/cart-list.component.html ====
==== START ./src/app/features/cart/components/cart-list/cart-list.component.scss ====
:host {
  display: block;
  min-height: calc(100vh - 150px); // Adjust based on navbar/footer height
}

// Custom styling for p-inputNumber to make it more compact
::ng-deep {
  .p-inputnumber {
    .p-inputnumber-input {
      width: 3rem !important;
      text-align: center;
      padding: 0.5rem;
    }

    .p-button {
      padding: 0.5rem;
      width: 2.5rem;
    }
  }

  .p-tooltip .p-tooltip-text {
    font-size: 0.875rem;
  }
}==== END ./src/app/features/cart/components/cart-list/cart-list.component.scss ====
==== START ./src/app/features/cart/components/cart-list/cart-list.component.ts ====
import { Component, computed, inject, signal } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { MessageModule } from 'primeng/message';
import { InputNumberModule } from 'primeng/inputnumber';
import { TooltipModule } from 'primeng/tooltip';
import { ConfirmationService } from 'primeng/api';
import {
  injectQuery,
  injectMutation,
} from '@tanstack/angular-query-experimental';

import { CartQueries } from '../../queries/cart.queries';
import { BasketItemDTO, BasketDTO } from '@core/models';
import { RouterLink } from '@angular/router';
import { StorageUtils } from '@shared/utils/storage.utils';
import { STORAGE_KEYS } from '@core/constants/storage-keys';

@Component({
  selector: 'app-cart-list',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    RouterLink,
    CurrencyPipe,
    ButtonModule,
    CardModule,
    ProgressSpinnerModule,
    MessageModule,
    InputNumberModule,
    TooltipModule,
  ],
  templateUrl: './cart-list.component.html',
  styleUrls: ['./cart-list.component.scss'],
})
export class CartListComponent {
  private cartQueries = inject(CartQueries);
  private confirmationService = inject(ConfirmationService);

  private basketId =
    StorageUtils.getLocalItem<string>(STORAGE_KEYS.BASKET_ID) || 'default';

  basketQuery = injectQuery(() =>
    this.cartQueries.getBasketById(this.basketId)
  );
  updateBasketMutation = injectMutation(() => this.cartQueries.updateBasket());
  deleteBasketMutation = injectMutation(() => this.cartQueries.deleteBasket());

  updatingItem = signal<number | null>(null);

  updateQuantity(item: BasketItemDTO, newQuantity: number | string): void {
    const quantity =
      typeof newQuantity === 'string' ? parseInt(newQuantity, 10) : newQuantity;

    if (quantity <= 0) {
      this.removeItem(item);
      return;
    }

    this.updatingItem.set(item.id);
    const currentBasket = this.basketQuery.data();
    if (currentBasket) {
      const updatedBasket: BasketDTO = {
        ...currentBasket,
        items: currentBasket.items.map((basketItem: BasketItemDTO) =>
          basketItem.id === item.id ? { ...basketItem, quantity } : basketItem
        ),
      };
      this.updateBasketMutation.mutate(updatedBasket, {
        onSettled: () => this.updatingItem.set(null),
      });
    }
  }

  removeItem(item: BasketItemDTO): void {
    this.confirmationService.confirm({
      message: `Are you sure you want to remove ${item.productName} from your cart?`,
      header: 'Confirm Removal',
      icon: 'pi pi-info-circle',
      accept: () => {
        const currentBasket = this.basketQuery.data();
        if (currentBasket) {
          const updatedBasket: BasketDTO = {
            ...currentBasket,
            items: currentBasket.items.filter(
              (i: BasketItemDTO) => i.id !== item.id
            ),
          };
          this.updateBasketMutation.mutate(updatedBasket);
        }
      },
    });
  }

  clearCart(): void {
    this.confirmationService.confirm({
      message: 'Are you sure you want to empty your entire cart?',
      header: 'Confirm Clear Cart',
      icon: 'pi pi-exclamation-triangle',
      accept: () => {
        if (this.basketQuery.data()?.id) {
          this.deleteBasketMutation.mutate(this.basketQuery.data()!.id);
        }
      },
    });
  }

  getSubtotal = computed(() => {
    const basket = this.basketQuery.data();
    if (!basket?.items) return 0;
    return basket.items.reduce(
      (total: number, item: BasketItemDTO) =>
        total + item.price * item.quantity,
      0
    );
  });

  getTotalPrice = computed(() => {
    const shipping = this.basketQuery.data()?.shippingPrice || 0;
    return this.getSubtotal() + shipping;
  });
}
==== END ./src/app/features/cart/components/cart-list/cart-list.component.ts ====
==== START ./src/app/features/cart/queries/cart.queries.ts ====
import { inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { lastValueFrom } from 'rxjs';
import { QueryClient } from '@tanstack/angular-query-experimental';
import { API_ENDPOINTS } from '../../../core/constants/api-endpoints';
import { BasketDTO, ErrorDetails } from '@core/models';
import { API_URL } from 'app/app.config';
import { map } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class CartQueries {
  private http = inject(HttpClient);
  private queryClient = inject(QueryClient);
  private apiUrl = inject(API_URL);

  // Query keys
  private static readonly BASKET_KEY = ['basket'];

  // Get basket by id
  getBasketById(id: string) {
    return {
      queryKey: [...CartQueries.BASKET_KEY, id],
      queryFn: () => this.fetchBasket(id),
      staleTime: 1 * 60 * 1000, // 1 minute for cart data
      retry: 1,
    };
  }

  // Update basket (add, update, remove items)
  updateBasket() {
    return {
      mutationFn: (basket: BasketDTO) => this.updateBasketApi(basket),
      onSuccess: (updatedBasket: BasketDTO) => {
        this.queryClient.setQueryData(
          [...CartQueries.BASKET_KEY, updatedBasket.id],
          updatedBasket
        );
      },
      onError: (error: ErrorDetails) => {
        console.error('Failed to update basket:', error.errorMessage);
      },
      retry: 3,
    };
  }

  // Delete basket by id
  deleteBasket() {
    return {
      mutationFn: (id: string) => this.deleteBasketApi(id),
      onSuccess: (id: string) => {
        this.queryClient.invalidateQueries({
          queryKey: [...CartQueries.BASKET_KEY, id],
        });
        // Also remove the specific query data to reflect empty state immediately
        this.queryClient.setQueryData([...CartQueries.BASKET_KEY, id], null);
      },
      onError: (error: ErrorDetails) => {
        console.error('Failed to delete basket:', error.errorMessage);
      },
      retry: 3,
    };
  }

  // API methods
  private fetchBasket(id: string): Promise<BasketDTO> {
    return lastValueFrom(
      this.http.get<BasketDTO>(
        `${this.apiUrl}${API_ENDPOINTS.BASKETS.GET}/${id}`
      )
    );
  }

  private updateBasketApi(basket: BasketDTO): Promise<BasketDTO> {
    return lastValueFrom(
      this.http.post<BasketDTO>(
        `${this.apiUrl}${API_ENDPOINTS.BASKETS.ADD_ITEM}`,
        basket
      )
    );
  }

  private deleteBasketApi(id: string): Promise<string> {
    return lastValueFrom(
      this.http
        .delete<void>(`${this.apiUrl}${API_ENDPOINTS.BASKETS.GET}/${id}`)
        .pipe(map(() => id)) // Return id for onSuccess handler
    );
  }
}
==== END ./src/app/features/cart/queries/cart.queries.ts ====
==== START ./src/app/features/landing/components/landing-page/landing-page.component.html ====
<div class="space-y-12 my-8">
  <!-- Banner Carousel -->
  <section>
    <p-carousel
      [value]="bannerImages"
      [numVisible]="1"
      [numScroll]="1"
      [circular]="true"
      [autoplayInterval]="5000"
      aria-label="Promotional Banners"
    >
      <ng-template pTemplate="item" let-image>
        <img
          [src]="image.src"
          [alt]="image.alt"
          class="w-full h-auto md:h-96 object-cover rounded-2xl shadow-lg"
        />
      </ng-template>
    </p-carousel>
  </section>

  <!-- Category Shortcuts -->
  <section>
    <h2 class="text-2xl font-bold text-gray-900 mb-6">Shop by Category</h2>
    <div
      class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-4 text-center"
    >
      @for (category of categories; track category.label) {
      <a
        routerLink="/products"
        [queryParams]="{ type: category.typeId }"
        class="group"
      >
        <div
          class="flex items-center justify-center w-20 h-20 sm:w-24 sm:h-24 mx-auto rounded-full transition-all duration-300 group-hover:scale-110 group-hover:shadow-lg"
          [ngClass]="category.bgColor"
        >
          <i
            class="pi {{ category.icon }} text-3xl"
            [ngClass]="category.textColor"
          ></i>
        </div>
        <span
          class="mt-2 block font-medium text-sm text-gray-700 group-hover:text-primary-600"
          >{{ category.label }}</span
        >
      </a>
      }
    </div>
  </section>

  <!-- Featured Products -->
  <section>
    <div class="flex justify-between items-baseline mb-6">
      <h2 class="text-2xl font-bold text-gray-900">Featured Products</h2>
      <a
        routerLink="/products"
        class="text-sm font-semibold text-primary-600 hover:underline"
        >View All</a
      >
    </div>

    @if (isFeaturedProductsLoading()) {
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
      @for (i of [1,2,3,4]; track i) {
      <p-skeleton height="28rem"></p-skeleton>
      }
    </div>
    } @else { @if (featuredProductsData(); as products) {
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
      @for (product of products.data; track product.id) {
      <app-product-card
        [product]="product"
        (addToCartClicked)="handleAddToCart($event)"
      ></app-product-card>
      }
    </div>
    } }
  </section>

  <!-- Why Shop With Us -->
  <section class="bg-white p-8 rounded-2xl shadow-soft">
    <h2 class="text-2xl font-bold text-gray-900 mb-6 text-center">
      Why Shop With Us?
    </h2>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-8 text-center">
      <div class="flex flex-col items-center">
        <div
          class="flex items-center justify-center w-16 h-16 bg-primary-100 text-primary-600 rounded-full mb-4"
        >
          <i class="pi pi-truck text-3xl"></i>
        </div>
        <h3 class="text-lg font-semibold mb-2">Fast Delivery</h3>
        <p class="text-gray-600">
          Get your orders delivered to your doorstep in no time.
        </p>
      </div>
      <div class="flex flex-col items-center">
        <div
          class="flex items-center justify-center w-16 h-16 bg-green-100 text-green-600 rounded-full mb-4"
        >
          <i class="pi pi-shield text-3xl"></i>
        </div>
        <h3 class="text-lg font-semibold mb-2">Secure Payments</h3>
        <p class="text-gray-600">
          Your payments are safe and secure with our top-notch encryption.
        </p>
      </div>
      <div class="flex flex-col items-center">
        <div
          class="flex items-center justify-center w-16 h-16 bg-purple-100 text-purple-600 rounded-full mb-4"
        >
          <i class="pi pi-comments text-3xl"></i>
        </div>
        <h3 class="text-lg font-semibold mb-2">24/7 Support</h3>
        <p class="text-gray-600">
          Our support team is always here to help you with any queries.
        </p>
      </div>
    </div>
  </section>
</div>
==== END ./src/app/features/landing/components/landing-page/landing-page.component.html ====
==== START ./src/app/features/landing/components/landing-page/landing-page.component.scss ====
/* Custom styles for landing page if needed. Most styles are handled by Tailwind CSS. */ ==== END ./src/app/features/landing/components/landing-page/landing-page.component.scss ====
==== START ./src/app/features/landing/components/landing-page/landing-page.component.ts ====
import { Component, computed, inject, signal } from '@angular/core';
import { RouterLink } from '@angular/router';
import { CommonModule } from '@angular/common';
import { CarouselModule } from 'primeng/carousel';
import { SkeletonModule } from 'primeng/skeleton';
import { ButtonModule } from 'primeng/button';
import {
  injectQuery,
  injectMutation,
} from '@tanstack/angular-query-experimental';
import { ProductQueries } from '@features/products/queries/product.queries';
import { ProductCardComponent } from '@features/products/components/product-card/product-card.component';
import {
  ProductResponse,
  ProductSortingOptions,
  BasketItemDTO,
  BasketDTO,
} from '@core/models';
import { CartQueries } from '@features/cart/queries/cart.queries';
import { ToastService } from '@core/services/toast.service';
import { StorageUtils } from '@shared/utils/storage.utils';
import { STORAGE_KEYS } from '@core/constants/storage-keys';
import { v4 as uuidv4 } from 'uuid';

@Component({
  selector: 'app-landing-page',
  standalone: true,
  templateUrl: './landing-page.component.html',
  styleUrls: ['./landing-page.component.scss'],
  imports: [
    CommonModule,
    CarouselModule,
    RouterLink,
    SkeletonModule,
    ButtonModule,
    ProductCardComponent,
  ],
})
export class LandingPageComponent {
  private productQueries = inject(ProductQueries);
  private cartQueries = inject(CartQueries);
  private toastService = inject(ToastService);

  featuredProductsQuery = injectQuery(() =>
    this.productQueries.getProductsWithFilter({
      pageIndex: 0,
      pageSize: 4,
      sort: ProductSortingOptions.NameAsc,
    })
  );

  private basketId = signal(
    StorageUtils.getLocalItem<string>(STORAGE_KEYS.BASKET_ID)
  );
  currentBasket = injectQuery(() =>
    this.cartQueries.getBasketById(this.basketId()!)
  );
  updateBasketMutation = injectMutation(() => this.cartQueries.updateBasket());

  // Computed signals for template usage
  isFeaturedProductsLoading = computed(() =>
    this.featuredProductsQuery.isPending()
  );
  featuredProductsData = computed(() => this.featuredProductsQuery.data());
  isBasketLoading = computed(() => this.currentBasket.isPending());
  basketData = computed(() => this.currentBasket.data());
  isUpdateBasketPending = computed(() => this.updateBasketMutation.isPending());

  bannerImages = [
    {
      src: 'https://primefaces.org/cdn/primeng/images/galleria/galleria1.jpg',
      alt: 'Exciting new electronics collection',
    },
    {
      src: 'https://primefaces.org/cdn/primeng/images/galleria/galleria2.jpg',
      alt: 'Summer fashion sale up to 50% off',
    },
    {
      src: 'https://primefaces.org/cdn/primeng/images/galleria/galleria3.jpg',
      alt: 'Upgrade your home with our new appliances',
    },
  ];

  categories = [
    {
      label: 'Electronics',
      icon: 'pi-headphones',
      typeId: 1,
      bgColor: 'bg-blue-100',
      textColor: 'text-blue-600',
    },
    {
      label: 'Fashion',
      icon: 'pi-user',
      typeId: 2,
      bgColor: 'bg-pink-100',
      textColor: 'text-pink-600',
    },
    {
      label: 'Home',
      icon: 'pi-home',
      typeId: 3,
      bgColor: 'bg-green-100',
      textColor: 'text-green-600',
    },
    {
      label: 'Kids',
      icon: 'pi-prime',
      typeId: 4,
      bgColor: 'bg-yellow-100',
      textColor: 'text-yellow-600',
    },
    {
      label: 'Beauty',
      icon: 'pi-gift',
      typeId: 5,
      bgColor: 'bg-purple-100',
      textColor: 'text-purple-600',
    },
    {
      label: 'Mobiles',
      icon: 'pi-mobile',
      typeId: 6,
      bgColor: 'bg-gray-200',
      textColor: 'text-gray-700',
    },
    {
      label: 'Books',
      icon: 'pi-book',
      typeId: 7,
      bgColor: 'bg-indigo-100',
      textColor: 'text-indigo-600',
    },
    {
      label: 'Sports',
      icon: 'pi-bolt',
      typeId: 8,
      bgColor: 'bg-red-100',
      textColor: 'text-red-600',
    },
  ];

  handleAddToCart(product: ProductResponse) {
    let basket = this.basketData();

    if (!basket) {
      const newBasketId = uuidv4();
      this.basketId.set(newBasketId);
      StorageUtils.setLocalItem(STORAGE_KEYS.BASKET_ID, newBasketId);
      basket = { id: newBasketId, items: [], shippingPrice: 0 };
    }

    const itemIndex = basket.items.findIndex(
      (item: BasketItemDTO) => item.id === product.id
    );
    let newItems = [...basket.items];

    if (itemIndex > -1) {
      newItems[itemIndex] = {
        ...newItems[itemIndex],
        quantity: newItems[itemIndex].quantity + 1,
      };
    } else {
      newItems.push({
        id: product.id,
        productName: product.name,
        pictureUrl: product.pictureUrl,
        price: product.price,
        quantity: 1,
      });
    }

    const updatedBasket: BasketDTO = { ...basket, items: newItems };

    this.updateBasketMutation.mutate(updatedBasket, {
      onSuccess: () => {
        this.toastService.showSuccess(
          'Added to Cart',
          `${product.name} has been added.`
        );
      },
      onError: (error: any) => {
        this.toastService.showError('Error', 'Could not add item to cart.');
        console.error(error);
      },
    });
  }
}
==== END ./src/app/features/landing/components/landing-page/landing-page.component.ts ====
==== START ./src/app/features/orders/components/checkout/checkout.component.html ====
<div class="my-8">
  <div class="text-center mb-8">
    <h1 class="text-4xl font-bold text-gray-900">Checkout</h1>
    <p class="text-lg text-gray-600 mt-2">
      Complete your order by following the steps below.
    </p>
  </div>

  <div class="grid lg:grid-cols-3 gap-8 items-start">
    <!-- Steps and Form Column -->
    <div class="lg:col-span-2">
      <p-steps
        [model]="steps"
        [(activeIndex)]="activeStep"
        [readonly]="true"
      ></p-steps>

      <div class="mt-8 p-6 bg-white rounded-lg shadow-md">
        @switch (activeStep()) { @case (0) {
        <!-- Shipping Address Form -->
        <h2 class="text-2xl font-semibold mb-6">Shipping Address</h2>
        <form
          [formGroup]="addressForm"
          class="grid grid-cols-1 md:grid-cols-2 gap-6"
        >
          <!-- Full Name -->
          <div class="flex flex-col gap-1">
            <label for="fullName" class="font-semibold text-gray-700"
              >Full Name</label
            >
            <input
              pInputText
              id="fullName"
              type="text"
              placeholder="Enter your full name"
              formControlName="fullName"
              [invalid]="isInvalid('fullName')"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              aria-label="Full name"
              aria-describedby="fullName-error"
              tabindex="0"
            />
            @if (isInvalid('fullName')) {
            <p-message
              id="fullName-error"
              severity="error"
              size="small"
              variant="simple"
            >
              @if (addressForm.get('fullName')?.errors?.['required']) { Full
              name is required. }
            </p-message>
            }
          </div>

          <!-- Address Line 1 -->
          <div class="flex flex-col gap-1">
            <label for="address1" class="font-semibold text-gray-700"
              >Address Line 1</label
            >
            <input
              pInputText
              id="address1"
              type="text"
              placeholder="Enter your address"
              formControlName="address1"
              [invalid]="isInvalid('address1')"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              aria-label="Address line 1"
              aria-describedby="address1-error"
              tabindex="0"
            />
            @if (isInvalid('address1')) {
            <p-message
              id="address1-error"
              severity="error"
              size="small"
              variant="simple"
            >
              @if (addressForm.get('address1')?.errors?.['required']) { Address
              is required. }
            </p-message>
            }
          </div>

          <!-- Address Line 2 -->
          <div class="flex flex-col gap-1">
            <label for="address2" class="font-semibold text-gray-700"
              >Address Line 2 (Optional)</label
            >
            <input
              pInputText
              id="address2"
              type="text"
              placeholder="Apartment, suite, etc."
              formControlName="address2"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              aria-label="Address line 2"
              tabindex="0"
            />
          </div>

          <!-- City -->
          <div class="flex flex-col gap-1">
            <label for="city" class="font-semibold text-gray-700">City</label>
            <input
              pInputText
              id="city"
              type="text"
              placeholder="Enter your city"
              formControlName="city"
              [invalid]="isInvalid('city')"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              aria-label="City"
              aria-describedby="city-error"
              tabindex="0"
            />
            @if (isInvalid('city')) {
            <p-message
              id="city-error"
              severity="error"
              size="small"
              variant="simple"
            >
              @if (addressForm.get('city')?.errors?.['required']) { City is
              required. }
            </p-message>
            }
          </div>

          <!-- State -->
          <div class="flex flex-col gap-1">
            <label for="state" class="font-semibold text-gray-700"
              >State / Province</label
            >
            <input
              pInputText
              id="state"
              type="text"
              placeholder="Enter your state"
              formControlName="state"
              [invalid]="isInvalid('state')"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              aria-label="State or province"
              aria-describedby="state-error"
              tabindex="0"
            />
            @if (isInvalid('state')) {
            <p-message
              id="state-error"
              severity="error"
              size="small"
              variant="simple"
            >
              @if (addressForm.get('state')?.errors?.['required']) { State is
              required. }
            </p-message>
            }
          </div>

          <!-- ZIP Code -->
          <div class="flex flex-col gap-1">
            <label for="zipCode" class="font-semibold text-gray-700"
              >ZIP / Postal Code</label
            >
            <input
              pInputText
              id="zipCode"
              type="text"
              placeholder="Enter your ZIP code"
              formControlName="zipCode"
              [invalid]="isInvalid('zipCode')"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              aria-label="ZIP or postal code"
              aria-describedby="zipCode-error"
              tabindex="0"
            />
            @if (isInvalid('zipCode')) {
            <p-message
              id="zipCode-error"
              severity="error"
              size="small"
              variant="simple"
            >
              @if (addressForm.get('zipCode')?.errors?.['required']) { ZIP code
              is required. }
            </p-message>
            }
          </div>

          <!-- Country -->
          <div class="flex flex-col gap-1 md:col-span-2">
            <label for="country" class="font-semibold text-gray-700"
              >Country</label
            >
            <input
              pInputText
              id="country"
              type="text"
              placeholder="Enter your country"
              formControlName="country"
              [invalid]="isInvalid('country')"
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              aria-label="Country"
              aria-describedby="country-error"
              tabindex="0"
            />
            @if (isInvalid('country')) {
            <p-message
              id="country-error"
              severity="error"
              size="small"
              variant="simple"
            >
              @if (addressForm.get('country')?.errors?.['required']) { Country
              is required. }
            </p-message>
            }
          </div>
        </form>
        } @case (1) {
        <!-- Delivery Method Selection -->
        <h2 class="text-2xl font-semibold mb-6">Delivery Method</h2>
        @if (isDeliveryMethodsLoading()) {
        <div class="flex justify-center items-center h-32">
          <p-progressSpinner />
        </div>
        } @else { @if (deliveryMethodsData(); as methods) {
        <div class="space-y-4">
          @for (method of methods; track method.id) {
          <div
            (click)="onDeliveryMethodChange(method)"
            class="flex items-center p-4 border rounded-lg cursor-pointer transition-all"
            [ngClass]="{
              'border-blue-500 ring-2 ring-blue-200':
                selectedDeliveryMethod()?.id === method.id,
              'border-gray-200': selectedDeliveryMethod()?.id !== method.id
            }"
          >
            <p-radioButton
              name="deliveryMethod"
              [value]="method"
              [inputId]="'method' + method.id"
            ></p-radioButton>
            <label
              [for]="'method' + method.id"
              class="ml-4 flex-grow cursor-pointer"
            >
              <span class="font-semibold">{{ method.shortName }}</span>
              <p class="text-sm text-gray-500">
                {{ method.deliveryTime }} - {{ method.description }}
              </p>
            </label>
            <span class="font-bold">{{ method.price | currency }}</span>
          </div>
          }
        </div>
        } } } @case (2) {
        <!-- Payment Section -->
        <h2 class="text-2xl font-semibold mb-6">Payment</h2>
        <div
          class="p-8 border-2 border-dashed border-gray-300 rounded-lg text-center text-gray-500"
        >
          <i class="pi pi-credit-card text-4xl mb-4" aria-hidden="true"></i>
          <p class="text-lg font-medium mb-2">
            Secure Payment Form Placeholder
          </p>
          <p class="text-sm">(Stripe/Payment Gateway integration)</p>
        </div>
        } @case (3) {
        <!-- Review Order -->
        <h2 class="text-2xl font-semibold mb-6">Review Your Order</h2>
        <div class="space-y-6 p-6 border border-gray-200 rounded-lg bg-gray-50">
          <div>
            <h3 class="font-semibold text-lg mb-2">Shipping To:</h3>
            <p class="text-gray-700">{{ addressForm.value.fullName }}</p>
            <p class="text-gray-700">
              {{ addressForm.value.address1 }}, {{ addressForm.value.city }}
            </p>
          </div>
          <div>
            <h3 class="font-semibold text-lg mb-2">Delivery Method:</h3>
            <p class="text-gray-700">
              {{ selectedDeliveryMethod()?.shortName }} ({{
                selectedDeliveryMethod()?.price | currency
              }})
            </p>
          </div>
          <div>
            <h3 class="font-semibold text-lg mb-2">Items:</h3>
            <p class="text-gray-700">
              {{ basketData()?.items?.length || 0 }} items in your cart.
            </p>
          </div>
        </div>
        } }
      </div>
    </div>

    <!-- Order Summary Column -->
    <div class="lg:col-span-1 sticky top-24">
      @if (basketData(); as basket) {
      <p-card header="Order Summary" styleClass="shadow-medium">
        <div class="space-y-2 mb-4 max-h-60 overflow-y-auto pr-2">
          @for (item of basket.items; track item.id) {
          <div class="flex justify-between items-center text-sm">
            <span class="truncate pr-2"
              >{{ item.productName }} x {{ item.quantity }}</span
            >
            <span class="font-medium text-right">{{
              item.price * item.quantity | currency
            }}</span>
          </div>
          }
        </div>
        <hr />
        <div class="space-y-2 mt-4">
          <div class="flex justify-between">
            <span>Subtotal</span>
            <span class="font-medium">{{ getSubtotal() | currency }}</span>
          </div>
          <div class="flex justify-between">
            <span>Shipping</span>
            <span class="font-medium">{{
              selectedDeliveryMethod()?.price || 0 | currency
            }}</span>
          </div>
          <hr />
          <div class="flex justify-between font-bold text-xl mt-2">
            <span>Total</span>
            <span>{{ getTotalPrice() | currency }}</span>
          </div>
        </div>
      </p-card>
      }

      <div class="mt-6 flex justify-between">
        <p-button
          label="Back"
          icon="pi pi-arrow-left"
          (onClick)="prevStep()"
          [disabled]="activeStep() === 0"
          severity="secondary"
          [rounded]="true"
          aria-label="Go to previous step"
        ></p-button>

        @if (activeStep() < 3) {
        <p-button
          label="Next"
          icon="pi pi-arrow-right"
          iconPos="right"
          (onClick)="nextStep()"
          [disabled]="!canProceed()"
          [rounded]="true"
          aria-label="Go to next step"
        ></p-button>
        } @if (activeStep() === 3) {
        <p-button
          label="Place Order"
          icon="pi pi-check"
          (onClick)="onSubmit()"
          [loading]="createOrderMutation.isPending()"
          [rounded]="true"
          aria-label="Place order"
        ></p-button>
        }
      </div>
    </div>
  </div>
</div>
==== END ./src/app/features/orders/components/checkout/checkout.component.html ====
==== START ./src/app/features/orders/components/checkout/checkout.component.scss ====
:host {
  display: block;
}

.form-field {
  @apply flex flex-col gap-2;

  label {
    @apply font-semibold text-sm text-gray-700;
  }

  input[pInputText] {
    @apply w-full;
  }
}

// Style p-steps to be more modern
::ng-deep {
  .p-steps {
    .p-steps-item {
      .p-menuitem-link {
        @apply bg-transparent;

        .p-steps-number {
          @apply bg-gray-200 text-gray-700 border-2 border-gray-200 transition-all;
        }
        .p-steps-title {
          @apply text-gray-500 transition-all;
        }
      }

      &.p-steps-current .p-menuitem-link {
        .p-steps-number {
          @apply bg-primary-500 text-white border-primary-500;
        }
        .p-steps-title {
          @apply text-primary-600 font-semibold;
        }
      }
    }
  }
}==== END ./src/app/features/orders/components/checkout/checkout.component.scss ====
==== START ./src/app/features/orders/components/checkout/checkout.component.ts ====
import { Component, computed, effect, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import {
  ReactiveFormsModule,
  FormBuilder,
  FormGroup,
  Validators,
} from '@angular/forms';
import { Router } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { InputTextModule } from 'primeng/inputtext';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { StepsModule } from 'primeng/steps';
import { RadioButtonModule } from 'primeng/radiobutton';
import {
  injectQuery,
  injectMutation,
} from '@tanstack/angular-query-experimental';

import { OrderQueries } from '../../queries/order.queries';
import { CartQueries } from '../../../cart/queries/cart.queries';
import { UserQueries } from '../../../user/queries/user.queries';
import { CheckoutStore } from '../../store/checkout.store';
import {
  OrderRequest,
  DeliveryMethodResponse,
  BasketItemDTO,
  OrderResponse,
} from '@core/models';
import { StorageUtils } from '@shared/utils/storage.utils';
import { STORAGE_KEYS } from '@core/constants/storage-keys';
import { MessageModule } from 'primeng/message';

@Component({
  selector: 'app-checkout',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    CurrencyPipe,
    ButtonModule,
    CardModule,
    InputTextModule,
    ProgressSpinnerModule,
    StepsModule,
    RadioButtonModule,
    MessageModule,
  ],
  templateUrl: './checkout.component.html',
  styleUrls: ['./checkout.component.scss'],
})
export class CheckoutComponent {
  private orderQueries = inject(OrderQueries);
  private cartQueries = inject(CartQueries);
  private userQueries = inject(UserQueries);
  private checkoutStore = inject(CheckoutStore);
  private fb = inject(FormBuilder);
  private router = inject(Router);

  private basketId =
    StorageUtils.getLocalItem<string>(STORAGE_KEYS.BASKET_ID) || 'default';

  basketQuery = injectQuery(() =>
    this.cartQueries.getBasketById(this.basketId)
  );
  deliveryMethodsQuery = injectQuery(() =>
    this.orderQueries.getDeliveryMethods()
  );
  addressQuery = injectQuery(() => this.userQueries.getAddress());
  createOrderMutation = injectMutation(() => this.orderQueries.createOrder());
  updateAddressMutation = injectMutation(() =>
    this.userQueries.updateAddress()
  );

  isBasketLoading = computed(() => this.basketQuery.isPending());
  basketData = computed(() => this.basketQuery.data());
  isDeliveryMethodsLoading = computed(() =>
    this.deliveryMethodsQuery.isPending()
  );
  deliveryMethodsData = computed(() => this.deliveryMethodsQuery.data());
  isAddressLoading = computed(() => this.addressQuery.isPending());
  isCreateOrderPending = computed(() => this.createOrderMutation.isPending());

  steps = [
    { label: 'Shipping' },
    { label: 'Delivery' },
    { label: 'Payment' },
    { label: 'Review' },
  ];
  activeStep = this.checkoutStore.currentStepIndex;

  addressForm: FormGroup = this.fb.group({
    fullName: ['', [Validators.required, Validators.minLength(2)]],
    address1: ['', [Validators.required]],
    address2: [''],
    city: ['', [Validators.required]],
    state: ['', [Validators.required]],
    zipCode: ['', [Validators.required]],
    country: ['', [Validators.required]],
  });

  selectedDeliveryMethod = this.checkoutStore.deliveryMethod;

  isInvalid(controlName: string): boolean {
    const control = this.addressForm.get(controlName);
    return !!(control && control.invalid && (control.touched || control.dirty));
  }

  canProceed = computed(() => {
    switch (this.activeStep()) {
      case 0:
        return this.addressForm.valid;
      case 1:
        return !!this.selectedDeliveryMethod();
      case 2:
        return true; // Placeholder for payment validation
      default:
        return false;
    }
  });

  constructor() {
    effect(() => {
      const address = this.checkoutStore.address();
      if (address) this.addressForm.patchValue(address, { emitEvent: false });
    });
    effect(() => {
      const addrFromApi = this.addressQuery.data();
      if (addrFromApi && !this.checkoutStore.address()) {
        this.checkoutStore.setAddress(addrFromApi);
      }
    });
  }

  nextStep(): void {
    if (this.canProceed()) {
      if (this.activeStep() === 0) {
        this.checkoutStore.setAddress(this.addressForm.value);
      }
      this.checkoutStore.nextStep();
    } else {
      this.addressForm.markAllAsTouched();
    }
  }

  prevStep(): void {
    this.checkoutStore.previousStep();
  }

  onDeliveryMethodChange(method: DeliveryMethodResponse): void {
    this.checkoutStore.setDeliveryMethod(method);
  }

  getSubtotal = computed(() => {
    const basket = this.basketData();
    if (!basket?.items) return 0;
    return basket.items.reduce(
      (total: number, item: BasketItemDTO) =>
        total + item.price * item.quantity,
      0
    );
  });

  getTotalPrice = computed(() => {
    const deliveryCost = this.selectedDeliveryMethod()?.price || 0;
    return this.getSubtotal() + deliveryCost;
  });

  onSubmit(): void {
    const address = this.checkoutStore.address();
    const deliveryMethod = this.checkoutStore.deliveryMethod();
    const basket = this.basketData();

    if (address && deliveryMethod && basket) {
      this.updateAddressMutation.mutate(address, {
        onSuccess: () => {
          const orderRequest: OrderRequest = {
            basketId: basket.id,
            deliveryMethodId: deliveryMethod.id,
            shipToAddress: address,
          };
          this.createOrderMutation.mutate(orderRequest, {
            onSuccess: (order: OrderResponse) => {
              this.checkoutStore.resetCheckout();
              this.router.navigate(['/orders', order.id, 'success']);
            },
          });
        },
      });
    }
  }
}
==== END ./src/app/features/orders/components/checkout/checkout.component.ts ====
==== START ./src/app/features/orders/components/order-list/order-list.component.html ====
<div class="container mx-auto px-4 py-8">
  <div class="max-w-6xl mx-auto">
    <div class="flex justify-between items-center mb-8">
      <h1 class="text-3xl font-bold text-gray-900">My Orders</h1>
      <p-button
        label="Continue Shopping"
        icon="pi pi-shopping-cart"
        styleClass="p-button-outlined"
        (click)="continueShopping()"
      ></p-button>
    </div>

    @if (isOrdersLoading()) {
    <div class="flex justify-center items-center h-64">
      <div
        class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"
      ></div>
    </div>
    } @else if (ordersError()) {
    <div
      class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded"
    >
      <strong>Error:</strong> Failed to load orders.
    </div>
    } @else if (!ordersData() || ordersData()!.length === 0) {
    <div class="text-center py-12">
      <div class="text-gray-500 mb-4">
        <i class="pi pi-shopping-bag text-6xl"></i>
      </div>
      <h3 class="text-xl font-semibold text-gray-900 mb-2">No Orders Yet</h3>
      <p class="text-gray-600 mb-6">
        You haven't placed any orders yet. Start shopping to see your orders
        here.
      </p>
      <p-button
        label="Start Shopping"
        icon="pi pi-shopping-cart"
        (click)="continueShopping()"
      ></p-button>
    </div>
    } @else {
    <div class="space-y-6">
      @for (order of ordersData()!; track order.id) {
      <p-card>
        <div class="space-y-4">
          <!-- Order Header -->
          <div class="flex justify-between items-start">
            <div>
              <h3 class="text-lg font-semibold text-gray-900">
                Order #{{ order.id.substring(0, 8) }}
              </h3>
              <p class="text-sm text-gray-600">
                Placed on {{ order.orderDate | date : "mediumDate" }}
              </p>
            </div>
            <div class="flex items-center space-x-3">
              <p-tag
                [value]="getStatusLabel(order.status)"
                [styleClass]="getStatusColor(order.status)"
              ></p-tag>
              <p-button
                label="View Details"
                icon="pi pi-eye"
                styleClass="p-button-sm p-button-outlined"
                (click)="viewOrderDetails(order.id)"
              ></p-button>
            </div>
          </div>

          <!-- Order Items -->
          <div class="border-t pt-4">
            <div class="space-y-3">
              @for (item of order.items; track item.productId) {
              <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                  <img
                    [src]="item.pictureUrl"
                    [alt]="item.name"
                    class="w-12 h-12 object-cover rounded"
                  />
                  <div>
                    <div class="font-medium text-gray-900">
                      {{ item.name }}
                    </div>
                    <div class="text-sm text-gray-500">
                      Qty: {{ item.quantity }}
                    </div>
                  </div>
                </div>
                <div class="font-medium text-gray-900">
                  {{ item.price * item.quantity | currency }}
                </div>
              </div>
              }
            </div>
          </div>

          <!-- Order Summary -->
          <div class="border-t pt-4">
            <div class="flex justify-between items-center">
              <div class="space-y-1">
                <div class="text-sm text-gray-600">
                  Delivery: {{ order.deliveryMethod }}
                </div>
                <div class="text-sm text-gray-600">
                  Address: {{ order.shipToAddress.address1 }},
                  {{ order.shipToAddress.city }}
                </div>
              </div>
              <div class="text-right">
                <div class="text-sm text-gray-600">
                  Subtotal: {{ order.subtotal | currency }}
                </div>
                <div class="text-sm text-gray-600">
                  Shipping: {{ order.deliveryCost | currency }}
                </div>
                <div class="font-bold text-lg text-gray-900">
                  Total: {{ order.total | currency }}
                </div>
              </div>
            </div>
          </div>

          <!-- Order Actions -->
          <div class="border-t pt-4">
            <div class="flex justify-between items-center">
              <div class="text-sm text-gray-600">
                Payment ID: {{ order.paymentIntentId.substring(0, 12) }}...
              </div>
              <div class="flex space-x-2">
                @if (order.status === 'Pending') {
                <p-button
                  label="Cancel Order"
                  icon="pi pi-times"
                  styleClass="p-button-sm p-button-danger p-button-outlined"
                  (click)="cancelOrder(order.id)"
                ></p-button>
                } @if (order.status === 'Shipped') {
                <p-button
                  label="Track Package"
                  icon="pi pi-truck"
                  styleClass="p-button-sm p-button-outlined"
                  (click)="trackPackage(order.id)"
                ></p-button>
                } @if (order.status === 'Delivered') {
                <p-button
                  label="Write Review"
                  icon="pi pi-star"
                  styleClass="p-button-sm p-button-outlined"
                  (click)="writeReview(order.id)"
                ></p-button>
                }
              </div>
            </div>
          </div>
        </div>
      </p-card>
      }
    </div>
    }
  </div>
</div>
==== END ./src/app/features/orders/components/order-list/order-list.component.html ====
==== START ./src/app/features/orders/components/order-list/order-list.component.scss ====
// Order List Component Styles
.order-list {
  &__header {
    color: #1f2937;
    font-weight: 700;
  }
  
  &__card {
    transition: box-shadow 0.3s ease;
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
    padding: 1.5rem;
    
    &:hover {
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }
  }
  
  &__item {
    transition: background-color 0.2s ease;
    
    &:hover {
      background-color: #f9fafb;
    }
  }
  
  &__image {
    border-radius: 0.375rem;
    object-fit: cover;
  }
  
  &__status {
    &--pending {
      background-color: #fef3c7;
      color: #92400e;
    }
    
    &--shipped {
      background-color: #dbeafe;
      color: #1e40af;
    }
    
    &--delivered {
      background-color: #d1fae5;
      color: #065f46;
    }
    
    &--cancelled {
      background-color: #f3f4f6;
      color: #374151;
    }
  }
  
  &__button {
    transition: all 0.2s ease;
    
    &:hover:not(:disabled) {
      transform: translateY(-1px);
    }
  }
  
  &__empty {
    .icon {
      color: #9ca3af;
    }
  }
} ==== END ./src/app/features/orders/components/order-list/order-list.component.scss ====
==== START ./src/app/features/orders/components/order-list/order-list.component.ts ====
import { Component, inject, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { CardModule } from 'primeng/card';
import { ButtonModule } from 'primeng/button';
import { TagModule } from 'primeng/tag';
import { TableModule } from 'primeng/table';
import { PaginatorModule } from 'primeng/paginator';
import { OrderResponse } from '@core/models';
import { injectQuery } from '@tanstack/angular-query-experimental';
import { lastValueFrom } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../../../environments/environment';
import { API_ENDPOINTS } from '@core/constants/api-endpoints';
import {
  ORDER_STATUS_LABELS,
  ORDER_STATUS_COLORS,
} from '@core/enums/order-status.enum';

@Component({
  selector: 'app-order-list',
  standalone: true,
  imports: [
    CommonModule,
    CardModule,
    ButtonModule,
    TagModule,
    TableModule,
    PaginatorModule,
  ],
  templateUrl: './order-list.component.html',
  styleUrls: ['./order-list.component.scss'],
})
export class OrderListComponent {
  private http = inject(HttpClient);
  private router = inject(Router);

  // Query for user orders
  ordersQuery = injectQuery(() => ({
    queryKey: ['orders'],
    queryFn: () =>
      lastValueFrom(
        this.http.get<OrderResponse[]>(
          `${environment.apiUrl}${API_ENDPOINTS.ORDERS.GET_ORDERS}`
        )
      ),
    staleTime: 2 * 60 * 1000, // 2 minutes
    retry: 1,
  }));

  // Computed signals for template usage
  isOrdersLoading = computed(() => this.ordersQuery.isPending());
  ordersData = computed(() => this.ordersQuery.data());
  ordersError = computed(() => this.ordersQuery.error());

  getStatusLabel(status: string): string {
    return (
      ORDER_STATUS_LABELS[status as keyof typeof ORDER_STATUS_LABELS] || status
    );
  }

  getStatusColor(status: string): string {
    return (
      ORDER_STATUS_COLORS[status as keyof typeof ORDER_STATUS_COLORS] ||
      'bg-gray-500'
    );
  }

  viewOrderDetails(orderId: string): void {
    this.router.navigate(['/orders', orderId]);
  }

  cancelOrder(orderId: string): void {
    // Implement cancel order logic
    console.log('Cancel order:', orderId);
  }

  trackPackage(orderId: string): void {
    // Implement track package logic
    console.log('Track package:', orderId);
  }

  writeReview(orderId: string): void {
    // Implement write review logic
    console.log('Write review:', orderId);
  }

  continueShopping(): void {
    this.router.navigate(['/products']);
  }
}
==== END ./src/app/features/orders/components/order-list/order-list.component.ts ====
==== START ./src/app/features/orders/queries/order.queries.ts ====
import { inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { lastValueFrom } from 'rxjs';
import { QueryClient } from '@tanstack/angular-query-experimental';
import { API_ENDPOINTS } from '../../../core/constants/api-endpoints';
import {
  OrderRequest,
  OrderResponse,
  DeliveryMethodResponse,
  OrderListResponse,
  ErrorDetails,
} from '@core/models';
import { API_URL } from 'app/app.config';

@Injectable({ providedIn: 'root' })
export class OrderQueries {
  private http = inject(HttpClient);
  private queryClient = inject(QueryClient);
  private apiUrl = inject(API_URL);

  // Query keys
  private static readonly ORDERS_KEY = ['orders'];
  private static readonly DELIVERY_METHODS_KEY = ['deliveryMethods'];

  // Get user orders
  getOrders() {
    return {
      queryKey: OrderQueries.ORDERS_KEY,
      queryFn: () => this.fetchOrders(),
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: 1,
    };
  }

  // Get delivery methods
  getDeliveryMethods() {
    return {
      queryKey: OrderQueries.DELIVERY_METHODS_KEY,
      queryFn: () => this.fetchDeliveryMethods(),
      staleTime: 30 * 60 * 1000, // 30 minutes
      retry: 1,
    };
  }

  // Create order mutation
  createOrder() {
    return {
      mutationFn: (request: OrderRequest) => this.createOrderRequest(request),
      onSuccess: () => {
        // Invalidate orders query
        this.queryClient.invalidateQueries({
          queryKey: OrderQueries.ORDERS_KEY,
        });
        // Invalidate basket query (since order creation clears the basket)
        this.queryClient.invalidateQueries({ queryKey: ['basket'] });
      },
      onError: (error: ErrorDetails) => {
        console.error('Order creation failed:', error.errorMessage);
      },
      retry: 3,
    };
  }

  // API methods
  private fetchOrders(): Promise<OrderListResponse> {
    return lastValueFrom(
      this.http.get<OrderListResponse>(
        `${this.apiUrl}${API_ENDPOINTS.ORDERS.GET_ORDERS}`
      )
    );
  }

  private fetchDeliveryMethods(): Promise<DeliveryMethodResponse[]> {
    return lastValueFrom(
      this.http.get<DeliveryMethodResponse[]>(
        `${this.apiUrl}${API_ENDPOINTS.ORDERS.DELIVERY_METHODS}`
      )
    );
  }

  private createOrderRequest(request: OrderRequest): Promise<OrderResponse> {
    return lastValueFrom(
      this.http.post<OrderResponse>(
        `${this.apiUrl}${API_ENDPOINTS.ORDERS.CREATE}`,
        request
      )
    );
  }
}
==== END ./src/app/features/orders/queries/order.queries.ts ====
==== START ./src/app/features/orders/store/checkout.store.ts ====
import {
  signalStore,
  withState,
  withComputed,
  withMethods,
  withHooks,
  patchState,
} from '@ngrx/signals';
import { computed, effect } from '@angular/core';
import { AddressDTO } from '../../../core/models/address.model';
import { DeliveryMethodResponse } from '../../../core/models/order.model';
import { STORAGE_KEYS } from '../../../core/constants/storage-keys';
import { StorageUtils } from '../../../shared/utils/storage.utils';

export enum CheckoutStep {
  ADDRESS = 'address',
  DELIVERY = 'delivery',
  PAYMENT = 'payment',
  REVIEW = 'review',
}

const STEPS_ORDER = [
  CheckoutStep.ADDRESS,
  CheckoutStep.DELIVERY,
  CheckoutStep.PAYMENT,
  CheckoutStep.REVIEW,
];

export interface CheckoutState {
  currentStep: CheckoutStep;
  address: AddressDTO | null;
  deliveryMethod: DeliveryMethodResponse | null;
  isLoading: boolean;
  error: string | null;
}

const initialState: CheckoutState = {
  currentStep: CheckoutStep.ADDRESS,
  address: null,
  deliveryMethod: null,
  isLoading: false,
  error: null,
};

export const CheckoutStore = signalStore(
  { providedIn: 'root' },
  withState<CheckoutState>(initialState),
  withComputed(({ currentStep }) => ({
    currentStepIndex: computed(() => STEPS_ORDER.indexOf(currentStep())),
  })),
  withMethods((store) => ({
    setStep(step: CheckoutStep) {
      patchState(store, { currentStep: step });
    },
    nextStep() {
      const currentIndex = STEPS_ORDER.indexOf(store.currentStep());
      if (currentIndex < STEPS_ORDER.length - 1) {
        patchState(store, { currentStep: STEPS_ORDER[currentIndex + 1] });
      }
    },
    previousStep() {
      const currentIndex = STEPS_ORDER.indexOf(store.currentStep());
      if (currentIndex > 0) {
        patchState(store, { currentStep: STEPS_ORDER[currentIndex - 1] });
      }
    },
    setAddress(address: AddressDTO) {
      patchState(store, { address, error: null });
    },
    setDeliveryMethod(deliveryMethod: DeliveryMethodResponse | null) {
      patchState(store, { deliveryMethod, error: null });
    },
    setLoading(isLoading: boolean) {
      patchState(store, { isLoading });
    },
    setError(error: string | null) {
      patchState(store, { error });
    },
    resetCheckout() {
      patchState(store, initialState);
      StorageUtils.removeLocalItem(STORAGE_KEYS.CHECKOUT_ADDRESS);
      StorageUtils.removeLocalItem(STORAGE_KEYS.SELECTED_DELIVERY_METHOD);
    },
  })),
  withHooks({
    onInit(store) {
      const savedAddress = StorageUtils.getLocalItem<AddressDTO>(
        STORAGE_KEYS.CHECKOUT_ADDRESS
      );
      const savedDeliveryMethod =
        StorageUtils.getLocalItem<DeliveryMethodResponse>(
          STORAGE_KEYS.SELECTED_DELIVERY_METHOD
        );

      patchState(store, {
        address: savedAddress,
        deliveryMethod: savedDeliveryMethod,
      });

      // Auto-save to localStorage
      effect(() => {
        const address = store.address();
        if (address) {
          StorageUtils.setLocalItem(STORAGE_KEYS.CHECKOUT_ADDRESS, address);
        }
      });
      effect(() => {
        const deliveryMethod = store.deliveryMethod();
        if (deliveryMethod) {
          StorageUtils.setLocalItem(
            STORAGE_KEYS.SELECTED_DELIVERY_METHOD,
            deliveryMethod
          );
        }
      });
    },
  })
);
==== END ./src/app/features/orders/store/checkout.store.ts ====
==== START ./src/app/features/payments/components/payment/payment.component.html ====
<div class="container mx-auto px-4 py-8">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold text-gray-900 mb-8">Payment</h1>

    @if (isBasketLoading()) {
    <div class="flex justify-center items-center h-64">
      <p-progressSpinner styleClass="w-12 h-12" />
    </div>
    } @else if (basketError()) {
    <p-message severity="error" size="small" variant="simple" styleClass="mb-4">
      Failed to load basket information.
    </p-message>
    } @else {
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <!-- Payment Form -->
      <div>
        <p-card header="Payment Information" styleClass="shadow-md">
          <form #paymentForm="ngForm" class="space-y-6">
            <!-- Payment Method Selection -->
            <div class="flex flex-col gap-1">
              <label class="font-semibold text-gray-700">Payment Method</label>
              <div class="space-y-3">
                <div class="flex items-center">
                  <p-radioButton
                    name="paymentMethod"
                    value="card"
                    [(ngModel)]="selectedPaymentMethod"
                    [inputId]="'card'"
                    styleClass="mr-3"
                  ></p-radioButton>
                  <label
                    for="card"
                    class="text-sm text-gray-700 cursor-pointer"
                  >
                    Credit/Debit Card
                  </label>
                </div>
                <div class="flex items-center">
                  <p-radioButton
                    name="paymentMethod"
                    value="paypal"
                    [(ngModel)]="selectedPaymentMethod"
                    [inputId]="'paypal'"
                    styleClass="mr-3"
                  ></p-radioButton>
                  <label
                    for="paypal"
                    class="text-sm text-gray-700 cursor-pointer"
                  >
                    PayPal
                  </label>
                </div>
              </div>
            </div>

            <!-- Card Information (if card selected) -->
            @if (selectedPaymentMethod() === 'card') {
            <div class="space-y-4">
              <div class="flex flex-col gap-1">
                <label for="cardNumber" class="font-semibold text-gray-700"
                  >Card Number</label
                >
                <input
                  pInputText
                  id="cardNumber"
                  type="text"
                  placeholder="1234 5678 9012 3456"
                  [(ngModel)]="cardNumber"
                  name="cardNumber"
                  #cardNumberModel="ngModel"
                  [invalid]="
                    cardNumberModel.invalid &&
                    (cardNumberModel.touched || paymentForm.submitted)
                  "
                  styleClass="w-full"
                  inputStyleClass="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  aria-label="Card number"
                  aria-describedby="cardNumber-error"
                  tabindex="0"
                />
                @if (cardNumberModel.invalid && (cardNumberModel.touched ||
                paymentForm.submitted)) {
                <p-message
                  id="cardNumber-error"
                  severity="error"
                  size="small"
                  variant="simple"
                  styleClass="mt-1"
                >
                  Please enter a valid card number.
                </p-message>
                }
              </div>

              <div class="grid grid-cols-2 gap-4">
                <div class="flex flex-col gap-1">
                  <label for="expiryDate" class="font-semibold text-gray-700"
                    >Expiry Date</label
                  >
                  <input
                    pInputText
                    id="expiryDate"
                    type="text"
                    placeholder="MM/YY"
                    [(ngModel)]="expiryDate"
                    name="expiryDate"
                    #expiryDateModel="ngModel"
                    [invalid]="
                      expiryDateModel.invalid &&
                      (expiryDateModel.touched || paymentForm.submitted)
                    "
                    styleClass="w-full"
                    inputStyleClass="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    aria-label="Expiry date"
                    aria-describedby="expiryDate-error"
                    tabindex="0"
                  />
                  @if (expiryDateModel.invalid && (expiryDateModel.touched ||
                  paymentForm.submitted)) {
                  <p-message
                    id="expiryDate-error"
                    severity="error"
                    size="small"
                    variant="simple"
                    styleClass="mt-1"
                  >
                    Please enter a valid expiry date.
                  </p-message>
                  }
                </div>

                <div class="flex flex-col gap-1">
                  <label for="cvv" class="font-semibold text-gray-700"
                    >CVV</label
                  >
                  <input
                    pInputText
                    id="cvv"
                    type="text"
                    placeholder="123"
                    [(ngModel)]="cvv"
                    name="cvv"
                    #cvvModel="ngModel"
                    [invalid]="
                      cvvModel.invalid &&
                      (cvvModel.touched || paymentForm.submitted)
                    "
                    styleClass="w-full"
                    inputStyleClass="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    aria-label="CVV"
                    aria-describedby="cvv-error"
                    tabindex="0"
                  />
                  @if (cvvModel.invalid && (cvvModel.touched ||
                  paymentForm.submitted)) {
                  <p-message
                    id="cvv-error"
                    severity="error"
                    size="small"
                    variant="simple"
                    styleClass="mt-1"
                  >
                    Please enter a valid CVV.
                  </p-message>
                  }
                </div>
              </div>
            </div>
            }

            <!-- Billing Address -->
            <div class="flex flex-col gap-1">
              <label for="billingAddress" class="font-semibold text-gray-700"
                >Billing Address</label
              >
              <textarea
                pInputText
                id="billingAddress"
                placeholder="Enter your billing address"
                [(ngModel)]="billingAddress"
                name="billingAddress"
                #billingAddressModel="ngModel"
                [invalid]="
                  billingAddressModel.invalid &&
                  (billingAddressModel.touched || paymentForm.submitted)
                "
                [rows]="3"
                styleClass="w-full"
                inputStyleClass="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                aria-label="Billing address"
                aria-describedby="billingAddress-error"
                tabindex="0"
              ></textarea>
              @if (billingAddressModel.invalid && (billingAddressModel.touched
              || paymentForm.submitted)) {
              <p-message
                id="billingAddress-error"
                severity="error"
                size="small"
                variant="simple"
                styleClass="mt-1"
              >
                Please enter your billing address.
              </p-message>
              }
            </div>

            <!-- Terms and Conditions -->
            <div class="flex items-center">
              <p-checkbox
                id="terms"
                [(ngModel)]="acceptedTerms"
                name="terms"
                [binary]="true"
                styleClass="mr-3"
              ></p-checkbox>
              <label for="terms" class="text-sm text-gray-700 cursor-pointer">
                I agree to the
                <a href="#" class="text-blue-600 hover:underline"
                  >Terms and Conditions</a
                >
              </label>
            </div>

            <!-- Payment Button -->
            <p-button
              label="Pay Now"
              icon="pi pi-credit-card"
              [disabled]="!acceptedTerms() || isPaymentPending()"
              [loading]="isPaymentPending()"
              (click)="processPayment()"
              [rounded]="true"
              styleClass="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors duration-200"
              aria-label="Process payment"
            ></p-button>
          </form>
        </p-card>
      </div>

      <!-- Order Summary -->
      <div>
        <p-card header="Order Summary" styleClass="shadow-md">
          <div class="space-y-4">
            <!-- Items -->
            @for (item of basketData()?.items; track item.id) {
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <img
                  [src]="item.pictureUrl"
                  [alt]="item.productName"
                  class="w-12 h-12 object-cover rounded"
                />
                <div>
                  <div class="font-medium text-gray-900">
                    {{ item.productName }}
                  </div>
                  <div class="text-sm text-gray-500">
                    Qty: {{ item.quantity }}
                  </div>
                </div>
              </div>
              <div class="font-medium text-gray-900">
                {{ item.price * item.quantity | currency }}
              </div>
            </div>
            }

            <p-divider></p-divider>

            <!-- Totals -->
            <div class="space-y-2">
              <div class="flex justify-between text-sm text-gray-600">
                <span>Subtotal</span>
                <span>{{ getSubtotal() | currency }}</span>
              </div>
              <div class="flex justify-between text-sm text-gray-600">
                <span>Shipping</span>
                <span>{{ basketData()?.shippingPrice || 0 | currency }}</span>
              </div>
              <div class="flex justify-between text-sm text-gray-600">
                <span>Tax</span>
                <span>{{ getTax() | currency }}</span>
              </div>
              <p-divider></p-divider>
              <div class="flex justify-between font-bold text-lg">
                <span>Total</span>
                <span>{{ getTotal() | currency }}</span>
              </div>
            </div>
          </div>
        </p-card>

        <!-- Security Notice -->
        <div class="mt-4 p-4 bg-blue-50 rounded-lg">
          <div class="flex items-center space-x-2">
            <i class="pi pi-shield text-blue-600" aria-hidden="true"></i>
            <span class="text-sm text-blue-800">
              Your payment information is secure and encrypted
            </span>
          </div>
        </div>
      </div>
    </div>
    }
  </div>
</div>

<p-toast></p-toast>
==== END ./src/app/features/payments/components/payment/payment.component.html ====
==== START ./src/app/features/payments/components/payment/payment.component.scss ====
// Payment Component Styles
.payment {
  &__header {
    color: #1f2937;
    font-weight: 700;
  }
  
  &__form {
    .form-input {
      transition: border-color 0.2s ease;
      
      &:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
    }
  }
  
  &__radio {
    &:checked {
      accent-color: #3b82f6;
    }
  }
  
  &__checkbox {
    &:checked {
      accent-color: #3b82f6;
    }
  }
  
  &__button {
    transition: all 0.2s ease;
    
    &:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
  }
  
  &__summary {
    .item {
      transition: background-color 0.2s ease;
      
      &:hover {
        background-color: #f9fafb;
      }
    }
  }
  
  &__security {
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    border: 1px solid #93c5fd;
  }
} ==== END ./src/app/features/payments/components/payment/payment.component.scss ====
==== START ./src/app/features/payments/components/payment/payment.component.ts ====
import { Component, inject, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, ActivatedRoute } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { CardModule } from 'primeng/card';
import { ButtonModule } from 'primeng/button';
import { DividerModule } from 'primeng/divider';
import { TagModule } from 'primeng/tag';
import { ToastModule } from 'primeng/toast';
import { MessageModule } from 'primeng/message';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { RadioButtonModule } from 'primeng/radiobutton';
import { InputTextModule } from 'primeng/inputtext';
import { CheckboxModule } from 'primeng/checkbox';
import { MessageService } from 'primeng/api';
import { BasketDTO } from '@core/models';
import {
  injectQuery,
  injectMutation,
} from '@tanstack/angular-query-experimental';
import { lastValueFrom } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../../../environments/environment';
import { API_ENDPOINTS } from '@core/constants/api-endpoints';
import { StorageUtils } from '@shared/utils/storage.utils';
import { STORAGE_KEYS } from '@core/constants/storage-keys';

@Component({
  selector: 'app-payment',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    CardModule,
    ButtonModule,
    DividerModule,
    TagModule,
    ToastModule,
    MessageModule,
    ProgressSpinnerModule,
    RadioButtonModule,
    InputTextModule,
    CheckboxModule,
  ],
  providers: [MessageService],
  templateUrl: './payment.component.html',
  styleUrls: ['./payment.component.scss'],
})
export class PaymentComponent {
  private http = inject(HttpClient);
  private router = inject(Router);
  private route = inject(ActivatedRoute);
  private messageService = inject(MessageService);

  // Form signals
  selectedPaymentMethod = signal('card');
  cardNumber = signal('');
  expiryDate = signal('');
  cvv = signal('');
  billingAddress = signal('');
  acceptedTerms = signal(false);

  // Basket query
  basketId = signal(
    StorageUtils.getLocalItem<string>(STORAGE_KEYS.BASKET_ID) || ''
  );

  basketQuery = injectQuery(() => ({
    queryKey: ['basket', this.basketId()],
    queryFn: () =>
      lastValueFrom(
        this.http.get<BasketDTO>(
          `${environment.apiUrl}${API_ENDPOINTS.BASKETS.GET}/${this.basketId()}`
        )
      ),
    enabled: !!this.basketId(),
    staleTime: 1 * 60 * 1000, // 1 minute
    retry: 1,
  }));

  paymentMutation = injectMutation(() => ({
    mutationFn: (basketId: string) =>
      lastValueFrom(
        this.http.post<BasketDTO>(
          `${environment.apiUrl}${API_ENDPOINTS.PAYMENTS.CREATE_PAYMENT_INTENT}/${basketId}`,
          {}
        )
      ),
    onSuccess: (basket: BasketDTO) => {
      this.messageService.add({
        severity: 'success',
        summary: 'Payment Successful',
        detail: 'Your payment has been processed successfully.',
      });
      // Navigate to success page or order confirmation
      this.router.navigate(['/orders/success']);
    },
    onError: (error: any) => {
      this.messageService.add({
        severity: 'error',
        summary: 'Payment Failed',
        detail: 'There was an error processing your payment. Please try again.',
      });
    },
    retry: 3,
  }));

  // Computed signals for template usage
  isBasketLoading = computed(() => this.basketQuery.isPending());
  basketData = computed(() => this.basketQuery.data());
  basketError = computed(() => this.basketQuery.error());
  isPaymentPending = computed(() => this.paymentMutation.isPending());

  getSubtotal(): number {
    const basket = this.basketData();
    if (!basket?.items) return 0;
    return basket.items.reduce(
      (total, item) => total + item.price * item.quantity,
      0
    );
  }

  getTax(): number {
    return this.getSubtotal() * 0.1; // 10% tax
  }

  getTotal(): number {
    const basket = this.basketData();
    const shipping = basket?.shippingPrice || 0;
    return this.getSubtotal() + this.getTax() + shipping;
  }

  processPayment(): void {
    if (this.acceptedTerms() && this.basketId()) {
      this.paymentMutation.mutate(this.basketId());
    }
  }
}
==== END ./src/app/features/payments/components/payment/payment.component.ts ====
==== START ./src/app/features/payments/queries/payment.queries.ts ====
import { inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { lastValueFrom } from 'rxjs';
import {
  injectMutation,
  QueryClient,
} from '@tanstack/angular-query-experimental';
import { API_ENDPOINTS } from '../../../core/constants/api-endpoints';
import { BasketDTO, ErrorDetails } from '@core/models';
import { API_URL } from 'app/app.config';

export interface PaymentIntentRequest {
  basketId: string;
}

export interface PaymentWebhookRequest {
  // Add webhook request properties as needed
  [key: string]: any;
}

export class PaymentQueries {
  private http = inject(HttpClient);
  private queryClient = inject(QueryClient);
  private apiUrl = inject(API_URL);

  // Query keys
  private static readonly PAYMENT_INTENT_KEY = ['paymentIntent'];

  // Create payment intent mutation
  createPaymentIntent = injectMutation(() => ({
    mutationFn: (request: PaymentIntentRequest) =>
      this.createPaymentIntentRequest(request),
    onSuccess: (updatedBasket: BasketDTO) => {
      // Update basket with payment intent data
      this.queryClient.setQueryData(['basket'], updatedBasket);
    },
    onError: (error: ErrorDetails) => {
      console.error('Payment intent creation failed:', error.errorMessage);
    },
    retry: 3,
  }));

  // Process webhook mutation
  processWebhook = injectMutation(() => ({
    mutationFn: (request: PaymentWebhookRequest) =>
      this.processWebhookRequest(request),
    onSuccess: () => {
      // Invalidate relevant queries after webhook processing
      this.queryClient.invalidateQueries({ queryKey: ['orders'] });
      this.queryClient.invalidateQueries({ queryKey: ['basket'] });
    },
    onError: (error: ErrorDetails) => {
      console.error('Webhook processing failed:', error.errorMessage);
    },
    retry: 1,
  }));

  // API methods
  private createPaymentIntentRequest(
    request: PaymentIntentRequest
  ): Promise<BasketDTO> {
    return lastValueFrom(
      this.http.post<BasketDTO>(
        `${this.apiUrl}${API_ENDPOINTS.PAYMENTS.CREATE_PAYMENT_INTENT}`,
        request
      )
    );
  }

  private processWebhookRequest(request: PaymentWebhookRequest): Promise<void> {
    return lastValueFrom(
      this.http.post<void>(
        `${this.apiUrl}${API_ENDPOINTS.PAYMENTS.WEBHOOK}`,
        request
      )
    );
  }
}
==== END ./src/app/features/payments/queries/payment.queries.ts ====
==== START ./src/app/features/products/components/product-card/product-card.component.html ====
<p-card styleClass="product-card group">
  <ng-template pTemplate="header">
    <div
      class="relative overflow-hidden rounded-t-lg cursor-pointer"
      (click)="viewDetails()"
    >
      <img
        [src]="product.pictureUrl"
        [alt]="product.name"
        class="w-full h-56 object-cover transition-transform duration-300 ease-in-out group-hover:scale-110"
        (error)="onImageError()"
      />
      <p-tag
        [value]="product.productBrand"
        severity="info"
        styleClass="absolute top-2 left-2 !bg-opacity-80 backdrop-blur-sm"
      ></p-tag>
    </div>
  </ng-template>

  <h3
    class="text-lg font-semibold text-gray-800 truncate cursor-pointer hover:text-primary-600"
    [title]="product.name"
    (click)="viewDetails()"
  >
    {{ product.name }}
  </h3>

  <p class="text-sm text-gray-500 mb-4">{{ product.productType }}</p>

  <div class="mt-auto flex items-center justify-between">
    <span class="text-2xl font-bold text-gray-900">{{
      product.price | currency
    }}</span>
    <p-button
      icon="pi pi-cart-plus"
      [rounded]="true"
      pTooltip="Add to Cart"
      tooltipPosition="top"
      [loading]="isAddingToCart()"
      (click)="addToCart()"
    ></p-button>
  </div>
</p-card>
==== END ./src/app/features/products/components/product-card/product-card.component.html ====
==== START ./src/app/features/products/components/product-card/product-card.component.scss ====
:host {
  display: block;
  height: 100%;
}

.product-card {
  height: 100%;
  display: flex;
  flex-direction: column;
  transition: all 0.3s ease-in-out;

  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08);
  }

  ::ng-deep {
    .p-card-body {
      padding: 1rem;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    .p-card-content {
      padding: 0;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
  }
}==== END ./src/app/features/products/components/product-card/product-card.component.scss ====
==== START ./src/app/features/products/components/product-card/product-card.component.ts ====
import {
  Component,
  Input,
  Output,
  EventEmitter,
  inject,
  signal,
} from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { Router } from '@angular/router';
import { CardModule } from 'primeng/card';
import { ButtonModule } from 'primeng/button';
import { TagModule } from 'primeng/tag';
import { TooltipModule } from 'primeng/tooltip';
import { ProductResponse } from '@core/models';

@Component({
  selector: 'app-product-card',
  standalone: true,
  imports: [
    CommonModule,
    CurrencyPipe,
    CardModule,
    ButtonModule,
    TagModule,
    TooltipModule,
  ],
  templateUrl: './product-card.component.html',
  styleUrls: ['./product-card.component.scss'],
})
export class ProductCardComponent {
  @Input({ required: true }) product!: ProductResponse;
  @Output() addToCartClicked = new EventEmitter<ProductResponse>();

  private router = inject(Router);

  isAddingToCart = signal(false);

  addToCart(): void {
    // We emit the event and let the parent component handle the logic,
    // which has access to the cart state.
    this.isAddingToCart.set(true);
    this.addToCartClicked.emit(this.product);
    // The parent component will be responsible for setting this back to false
    // or the mutation's `onSettled` will implicitly handle it.
    // For a better UX, we'll just simulate a short delay.
    setTimeout(() => this.isAddingToCart.set(false), 1500);
  }

  viewDetails(): void {
    this.router.navigate(['/products', this.product.id]);
  }

  onImageError(): void {
    console.warn('Image failed to load for product:', this.product.name);
    // Optionally, set a placeholder image via a signal if needed
  }
}
==== END ./src/app/features/products/components/product-card/product-card.component.ts ====
==== START ./src/app/features/products/components/product-detail/product-detail.component.html ====
<div class="container mx-auto px-4 py-8">
  <div class="max-w-6xl mx-auto">
    @if (isProductLoading()) {
    <div class="flex justify-center items-center h-64">
      <div
        class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"
      ></div>
    </div>
    } @else if (productError()) {
    <div
      class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded"
    >
      <strong>Error:</strong> Failed to load product details.
    </div>
    } @else { @if (productData(); as product) {
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <!-- Product Image -->
      <div class="space-y-4">
        <div class="aspect-square bg-gray-100 rounded-lg overflow-hidden">
          <img
            [src]="product.pictureUrl"
            [alt]="product.name"
            class="w-full h-full object-cover"
          />
        </div>
        <div class="flex space-x-2">
          <div class="w-20 h-20 bg-gray-100 rounded-lg overflow-hidden">
            <img
              [src]="product.pictureUrl"
              [alt]="product.name"
              class="w-full h-full object-cover"
            />
          </div>
          <div class="w-20 h-20 bg-gray-100 rounded-lg overflow-hidden">
            <img
              [src]="product.pictureUrl"
              [alt]="product.name"
              class="w-full h-full object-cover"
            />
          </div>
          <div class="w-20 h-20 bg-gray-100 rounded-lg overflow-hidden">
            <img
              [src]="product.pictureUrl"
              [alt]="product.name"
              class="w-full h-full object-cover"
            />
          </div>
        </div>
      </div>

      <!-- Product Information -->
      <div class="space-y-6">
        <div>
          <h1 class="text-3xl font-bold text-gray-900 mb-2">
            {{ product.name }}
          </h1>
          <div class="flex items-center space-x-4 mb-4">
            <div class="flex items-center">
              <i class="pi pi-star-fill text-yellow-400 mr-1"></i>
              <span class="text-sm text-gray-600">4.5 (128 reviews)</span>
            </div>
            <div class="flex items-center">
              <i class="pi pi-tag text-gray-400 mr-1"></i>
              <span class="text-sm text-gray-600">{{
                product.productBrand
              }}</span>
            </div>
          </div>
          <div class="text-3xl font-bold text-blue-600 mb-4">
            {{ product.price | currency }}
          </div>
        </div>

        <!-- Product Description -->
        <div>
          <h3 class="text-lg font-semibold text-gray-900 mb-2">Description</h3>
          <p class="text-gray-600 leading-relaxed">
            {{ product.description }}
          </p>
        </div>

        <!-- Product Details -->
        <div class="space-y-3">
          <div class="flex justify-between">
            <span class="text-gray-600">Brand</span>
            <span class="font-medium">{{ product.productBrand }}</span>
          </div>
          <div class="flex justify-between">
            <span class="text-gray-600">Type</span>
            <span class="font-medium">{{ product.productType }}</span>
          </div>
          <div class="flex justify-between">
            <span class="text-gray-600">Availability</span>
            <span class="text-green-600 font-medium">In Stock</span>
          </div>
        </div>

        <!-- Quantity and Add to Cart -->
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Quantity
            </label>
            <div class="flex items-center space-x-3">
              <p-button
                icon="pi pi-minus"
                styleClass="p-button-sm p-button-outlined"
                (click)="decreaseQuantity()"
                [disabled]="quantity() <= 1"
              ></p-button>
              <span class="text-lg font-medium w-12 text-center">{{
                quantity()
              }}</span>
              <p-button
                icon="pi pi-plus"
                styleClass="p-button-sm p-button-outlined"
                (click)="increaseQuantity()"
              ></p-button>
            </div>
          </div>

          <div class="flex space-x-3">
            <p-button
              label="Add to Cart"
              icon="pi pi-shopping-cart"
              styleClass="flex-1"
              [disabled]="isAddToCartPending()"
              [loading]="isAddToCartPending()"
              (click)="addToCart()"
            ></p-button>
            <p-button
              label="Add to Wishlist"
              icon="pi pi-heart"
              styleClass="p-button-outlined"
              (click)="addToWishlist()"
            ></p-button>
          </div>
        </div>

        <!-- Shipping Information -->
        <div class="bg-gray-50 p-4 rounded-lg">
          <h4 class="font-semibold text-gray-900 mb-2">Shipping Information</h4>
          <div class="space-y-2 text-sm text-gray-600">
            <div class="flex items-center">
              <i class="pi pi-truck mr-2"></i>
              <span>Free shipping on orders over $50</span>
            </div>
            <div class="flex items-center">
              <i class="pi pi-clock mr-2"></i>
              <span>Estimated delivery: 3-5 business days</span>
            </div>
            <div class="flex items-center">
              <i class="pi pi-undo mr-2"></i>
              <span>30-day return policy</span>
            </div>
          </div>
        </div>
      </div>
    </div>
    } }

    <!-- Related Products -->
    <div class="mt-12">
      <h2 class="text-2xl font-bold text-gray-900 mb-6">Related Products</h2>
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        @for (i of [1, 2, 3, 4]; track i) {
        <div class="bg-white rounded-lg shadow-md overflow-hidden">
          <div class="aspect-square bg-gray-100">
            <div class="w-full h-full bg-gray-200 animate-pulse"></div>
          </div>
          <div class="p-4">
            <div class="h-4 bg-gray-200 rounded mb-2 animate-pulse"></div>
            <div class="h-3 bg-gray-200 rounded mb-2 animate-pulse"></div>
            <div class="h-6 bg-gray-200 rounded w-1/2 animate-pulse"></div>
          </div>
        </div>
        }
      </div>
    </div>
  </div>
</div>

<p-toast></p-toast>
==== END ./src/app/features/products/components/product-detail/product-detail.component.html ====
==== START ./src/app/features/products/components/product-detail/product-detail.component.scss ====
// Product Detail Component Styles
.product-detail {
  &__header {
    color: #1f2937;
    font-weight: 700;
  }
  
  &__image {
    transition: transform 0.3s ease;
    
    &:hover {
      transform: scale(1.02);
    }
  }
  
  &__thumbnail {
    transition: all 0.2s ease;
    cursor: pointer;
    
    &:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
  }
  
  &__price {
    color: #2563eb;
    font-weight: 700;
  }
  
  &__quantity {
    .quantity-control {
      transition: all 0.2s ease;
      
      &:hover:not(:disabled) {
        transform: scale(1.05);
      }
    }
  }
  
  &__button {
    transition: all 0.2s ease;
    
    &:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
  }
  
  &__shipping {
    background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
    border: 1px solid #e5e7eb;
  }
  
  &__related {
    .skeleton {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: .5;
  }
} ==== END ./src/app/features/products/components/product-detail/product-detail.component.scss ====
==== START ./src/app/features/products/components/product-detail/product-detail.component.ts ====
import { Component, inject, signal, computed } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { Router, ActivatedRoute } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { ToastModule } from 'primeng/toast';
import { v4 as uuidv4 } from 'uuid';

import { ProductResponse, BasketItemDTO, BasketDTO } from '@core/models';
import {
  injectQuery,
  injectMutation,
} from '@tanstack/angular-query-experimental';
import { ProductQueries } from '../../queries/product.queries';
import { CartQueries } from '@features/cart/queries/cart.queries';
import { ToastService } from '@core/services/toast.service';
import { StorageUtils } from '@shared/utils/storage.utils';
import { STORAGE_KEYS } from '@core/constants/storage-keys';

@Component({
  selector: 'app-product-detail',
  standalone: true,
  imports: [CommonModule, CurrencyPipe, ButtonModule, ToastModule],
  providers: [ToastService],
  templateUrl: './product-detail.component.html',
  styleUrls: ['./product-detail.component.scss'],
})
export class ProductDetailComponent {
  private route = inject(ActivatedRoute);
  private productQueries = inject(ProductQueries);
  private cartQueries = inject(CartQueries);
  private toastService = inject(ToastService);

  quantity = signal(1);
  productId = signal(0);

  constructor() {
    this.route.params.subscribe((params) => {
      this.productId.set(Number(params['id']));
    });
  }

  productQuery = injectQuery(() =>
    this.productQueries.getProductById(this.productId())
  );

  private basketId = signal(
    StorageUtils.getLocalItem<string>(STORAGE_KEYS.BASKET_ID)
  );
  basketQuery = injectQuery(() =>
    this.cartQueries.getBasketById(this.basketId() || '')
  );
  updateBasketMutation = injectMutation(() => this.cartQueries.updateBasket());

  isProductLoading = computed(() => this.productQuery.isPending());
  productData = computed(() => this.productQuery.data());
  productError = computed(() => this.productQuery.error());
  isAddToCartPending = computed(() => this.updateBasketMutation.isPending());

  addToCart(): void {
    const product = this.productData();
    if (!product) return;

    let basket = this.basketQuery.data();
    if (!basket) {
      const newBasketId = uuidv4();
      this.basketId.set(newBasketId);
      StorageUtils.setLocalItem(STORAGE_KEYS.BASKET_ID, newBasketId);
      basket = { id: newBasketId, items: [], shippingPrice: 0 };
    }

    const itemIndex = basket.items.findIndex((item) => item.id === product.id);
    let newItems = [...basket.items];

    if (itemIndex > -1) {
      newItems[itemIndex] = {
        ...newItems[itemIndex],
        quantity: newItems[itemIndex].quantity + this.quantity(),
      };
    } else {
      newItems.push({
        id: product.id,
        productName: product.name,
        pictureUrl: product.pictureUrl,
        price: product.price,
        quantity: this.quantity(),
      });
    }

    const updatedBasket: BasketDTO = { ...basket, items: newItems };

    this.updateBasketMutation.mutate(updatedBasket, {
      onSuccess: () => {
        this.toastService.showSuccess(
          'Added to Cart',
          `${product.name} has been added.`
        );
      },
      onError: (error: any) => {
        this.toastService.showError('Error', 'Could not add item to cart.');
        console.error(error);
      },
    });
  }

  decreaseQuantity(): void {
    this.quantity.update((q) => (q > 1 ? q - 1 : 1));
  }

  increaseQuantity(): void {
    this.quantity.update((q) => q + 1);
  }

  addToWishlist(): void {
    this.toastService.showInfo(
      'Coming Soon',
      'Wishlist feature is on its way!'
    );
  }

  onImageError(): void {
    console.warn('Image failed to load for product:', this.productData()?.name);
  }
}
==== END ./src/app/features/products/components/product-detail/product-detail.component.ts ====
==== START ./src/app/features/products/components/product-list/product-list.component.html ====
<div class="my-8">
  <!-- Filters -->
  <p-card styleClass="mb-8 shadow-md">
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
      <!-- Search Filter -->
      <div class="flex flex-col gap-2">
        <label for="search" class="font-semibold text-gray-700"
          >Search Products</label
        >
        <div class="relative">
          <input
            pInputText
            #searchInput
            id="search"
            name="search"
            type="text"
            placeholder="Search products..."
            [value]="filterStore.filters().search || ''"
            (input)="onSearchChange($event)"
            class="w-full h-10 px-4 py-2 pl-10 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors duration-200"
            aria-label="Search products"
            aria-describedby="search-error"
            [attr.aria-invalid]="searchError() ? 'true' : 'false'"
            tabindex="0"
          />
          <i
            class="pi pi-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 pointer-events-none"
          ></i>
        </div>
        @if (searchError()) {
        <p-message
          id="search-error"
          severity="error"
          [text]="searchError() || ''"
          styleClass="mt-1"
        ></p-message>
        }
      </div>

      <!-- Brand Filter -->
      <div class="flex flex-col gap-2">
        <label for="brand" class="font-semibold text-gray-700">Brand</label>
        <p-autocomplete
          id="brand"
          name="brand"
          [(ngModel)]="selectedBrand"
          [suggestions]="brandSuggestions"
          (completeMethod)="filterBrands($event)"
          (onSelect)="onBrandSelect($event.value)"
          (onClear)="onBrandClear()"
          [dropdown]="true"
          field="name"
          placeholder="All Brands"
          class="w-full"
          aria-label="Select brand"
          aria-describedby="brand-error"
        ></p-autocomplete>
        @if (brandError()) {
        <p-message
          id="brand-error"
          severity="error"
          [text]="brandError() || ''"
          styleClass="mt-1"
        ></p-message>
        }
      </div>

      <!-- Type Filter -->
      <div class="flex flex-col gap-2">
        <label for="type" class="font-semibold text-gray-700">Type</label>
        <p-autocomplete
          id="type"
          name="type"
          [(ngModel)]="selectedType"
          [suggestions]="typeSuggestions"
          (completeMethod)="filterTypes($event)"
          (onSelect)="onTypeSelect($event.value)"
          (onClear)="onTypeClear()"
          [dropdown]="true"
          field="name"
          placeholder="All Types"
          class="w-full"
          aria-label="Select product type"
          aria-describedby="type-error"
        ></p-autocomplete>
        @if (typeError()) {
        <p-message
          id="type-error"
          severity="error"
          [text]="typeError() || ''"
          styleClass="mt-1"
        ></p-message>
        }
      </div>

      <!-- Sort Filter -->
      <div class="flex flex-col gap-2">
        <label for="sort" class="font-semibold text-gray-700">Sort By</label>
        <p-autocomplete
          id="sort"
          name="sort"
          [(ngModel)]="selectedSort"
          [suggestions]="sortSuggestions"
          (completeMethod)="filterSorts($event)"
          (onSelect)="onSortSelect($event.value)"
          (onClear)="onSortClear()"
          [dropdown]="true"
          field="label"
          placeholder="Sort By"
          class="w-full"
          aria-label="Select sort option"
          aria-describedby="sort-error"
        ></p-autocomplete>
        @if (sortError()) {
        <p-message
          id="sort-error"
          severity="error"
          [text]="sortError() || ''"
          styleClass="mt-1"
        ></p-message>
        }
      </div>
    </div>
  </p-card>

  <!-- Loading Skeletons -->
  @if (isProductsLoading()) {
  <div
    class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"
  >
    @for (i of skeletonItems; track i) {
    <p-skeleton
      height="28rem"
      styleClass="rounded-lg"
      aria-label="Loading product skeleton"
    ></p-skeleton>
    }
  </div>
  }

  <!-- Error State -->
  @else if (productsError()) {
  <div class="text-center py-12">
    <p-message
      severity="error"
      text="We couldn't load products. Please try refreshing the page."
      styleClass="max-w-md mx-auto"
    ></p-message>
  </div>
  }

  <!-- Empty State -->
  @else if (!productsData()?.data?.length) {
  <div class="text-center py-20 bg-white rounded-2xl shadow-soft">
    <i
      class="pi pi-search-minus text-7xl text-gray-400 mb-6"
      aria-hidden="true"
    ></i>
    <h2 class="text-3xl font-bold text-gray-800 mb-2">No Products Found</h2>
    <p class="text-gray-600 mb-8">
      Try adjusting your filters to find what you're looking for.
    </p>
    <p-button
      label="Clear Filters"
      (onClick)="clearFilters()"
      [outlined]="true"
      [rounded]="true"
      aria-label="Clear all filters"
      tabindex="0"
    ></p-button>
  </div>
  }

  <!-- Product Grid -->
  @else { @if (productsData()?.data; as products) {
  <div
    class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"
  >
    @for (product of products; track product.id) {
    <app-product-card
      [product]="product"
      (addToCartClicked)="handleAddToCart($event)"
    ></app-product-card>
    }
  </div>

  <!-- Pagination -->
  @if (productsData()!.count > productsData()!.pageSize) {
  <p-paginator
    (onPageChange)="onPageChange($event)"
    [first]="productsData()!.pageIndex * productsData()!.pageSize"
    [rows]="productsData()!.pageSize"
    [totalRecords]="productsData()!.count"
    [rowsPerPageOptions]="[12, 24, 36]"
    styleClass="mt-8"
    aria-label="Product pagination"
  ></p-paginator>
  } } }
</div>
==== END ./src/app/features/products/components/product-list/product-list.component.html ====
==== START ./src/app/features/products/components/product-list/product-list.component.scss ====
:host {
  display: block;
}

.product-card {
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
  
  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
  }
}

.product-image {
  border-radius: 8px 8px 0 0;
  transition: opacity 0.2s ease-in-out;
  
  &:hover {
    opacity: 0.9;
  }
}

.product-description {
  line-height: 1.5;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}

.product-price {
  color: #059669; // green-600
  font-weight: 700;
}

.add-to-cart-btn {
  transition: all 0.2s ease-in-out;
  
  &:not(:disabled):hover {
    transform: scale(1.02);
  }
  
  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
}

.pagination-container {
  margin-top: 2rem;
  padding: 1rem 0;
}

.pagination-btn {
  transition: all 0.2s ease-in-out;
  
  &:not(:disabled):hover {
    transform: scale(1.05);
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
}

.pagination-info {
  font-weight: 500;
  color: #374151; // gray-700
}

// Responsive adjustments
@media (max-width: 768px) {
  .grid {
    gap: 1rem;
  }
  
  .product-card {
    margin-bottom: 1rem;
  }
  
  .pagination-container {
    flex-direction: column;
    gap: 1rem;
  }
}

// Loading and error states
.flex.justify-center.items-center.h-64 {
  min-height: 16rem;
  
  p-progress-spinner {
    ::ng-deep .p-progress-spinner {
      width: 3rem;
      height: 3rem;
    }
  }
}

// Message styling
p-message {
  ::ng-deep .p-message {
    max-width: 500px;
    margin: 0 auto;
  }
} ==== END ./src/app/features/products/components/product-list/product-list.component.scss ====
==== START ./src/app/features/products/components/product-list/product-list.component.ts ====
import { IconFieldModule } from 'primeng/iconfield';
import { Component, computed, effect, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { PaginatorModule, PaginatorState } from 'primeng/paginator';
import { CardModule } from 'primeng/card';
import { InputTextModule } from 'primeng/inputtext';

import { InputIconModule } from 'primeng/inputicon';
import { SkeletonModule } from 'primeng/skeleton';
import { MessageModule } from 'primeng/message';
import { ButtonModule } from 'primeng/button';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { v4 as uuidv4 } from 'uuid';
import {
  injectQuery,
  injectMutation,
} from '@tanstack/angular-query-experimental';

import { ProductQueries } from '../../queries/product.queries';
import { CartQueries } from '@features/cart/queries/cart.queries';
import { ProductFilterStore } from '../../store/product-filter.store';
import {
  ProductResponse,
  ProductSortingOptions,
  BasketItemDTO,
  BasketDTO,
  BrandResponse,
  TypeResponse,
} from '@core/models';
import { ProductCardComponent } from '../product-card/product-card.component';
import { ToastService } from '@core/services/toast.service';
import { StorageUtils } from '@shared/utils/storage.utils';
import { STORAGE_KEYS } from '@core/constants/storage-keys';
import { AutoCompleteModule } from 'primeng/autocomplete';

@Component({
  selector: 'app-product-list',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    ProductCardComponent,
    PaginatorModule,
    CardModule,
    InputTextModule,
    InputIconModule,
    IconFieldModule,
    SkeletonModule,
    MessageModule,
    ButtonModule,
    AutoCompleteModule,
  ],
  templateUrl: './product-list.component.html',
  styleUrls: ['./product-list.component.scss'],
})
export class ProductListComponent {
  private productQueries = inject(ProductQueries);
  private cartQueries = inject(CartQueries);
  private toastService = inject(ToastService);
  readonly filterStore = inject(ProductFilterStore);

  private searchSubject = new Subject<string>();

  productsQuery = injectQuery(() =>
    this.productQueries.getProductsWithFilter(this.filterStore.filters())
  );
  brandsQuery = injectQuery(() => this.productQueries.getBrands());
  typesQuery = injectQuery(() => this.productQueries.getTypes());

  private basketId = signal(
    StorageUtils.getLocalItem<string>(STORAGE_KEYS.BASKET_ID)
  );
  currentBasket = injectQuery(() =>
    this.cartQueries.getBasketById(this.basketId()!)
  );
  updateBasketMutation = injectMutation(() => this.cartQueries.updateBasket());

  // Computed signals for template usage
  isProductsLoading = computed(() => this.productsQuery.isPending());
  productsData = computed(() => this.productsQuery.data());
  productsError = computed(() => this.productsQuery.error());
  isBrandsLoading = computed(() => this.brandsQuery.isPending());
  brandsData = computed(() => this.brandsQuery.data());
  isTypesLoading = computed(() => this.typesQuery.isPending());
  typesData = computed(() => this.typesQuery.data());
  isBasketLoading = computed(() => this.currentBasket.isPending());
  basketData = computed(() => this.currentBasket.data());
  isUpdateBasketPending = computed(() => this.updateBasketMutation.isPending());

  sortOptions = [
    { label: 'Name (A-Z)', value: ProductSortingOptions.NameAsc },
    { label: 'Name (Z-A)', value: ProductSortingOptions.NameDesc },
    { label: 'Price (Low to High)', value: ProductSortingOptions.PriceAsc },
    { label: 'Price (High to Low)', value: ProductSortingOptions.PriceDesc },
  ];

  skeletonItems = Array(this.filterStore.filters().pageSize);

  searchError = signal<string | null>(null);
  brandError = signal<string | null>(null);
  typeError = signal<string | null>(null);
  sortError = signal<string | null>(null);

  selectedBrand: BrandResponse | null = null;
  brandSuggestions: BrandResponse[] = [];
  selectedType: TypeResponse | null = null;
  typeSuggestions: TypeResponse[] = [];
  selectedSort: { label: string; value: ProductSortingOptions } | null = null;
  sortSuggestions: { label: string; value: ProductSortingOptions }[] = [];

  constructor() {
    this.searchSubject
      .pipe(debounceTime(500), distinctUntilChanged())
      .subscribe((search: string) => {
        this.filterStore.setSearch(search);
        this.searchError.set(null);
      });

    // Sync local component state with the filter store
    effect(() => {
      const filters = this.filterStore.filters();
      this.selectedBrand =
        this.brandsData()?.find((b) => b.id === filters.brandId) || null;
      this.selectedType =
        this.typesData()?.find((t) => t.id === filters.typeId) || null;
      this.selectedSort =
        this.sortOptions.find((s) => s.value === filters.sort) || null;
    });
  }

  filterBrands(event: { query: string }) {
    this.brandSuggestions =
      this.brandsData()?.filter((b) =>
        b.name.toLowerCase().includes(event.query.toLowerCase())
      ) || [];
  }

  filterTypes(event: { query: string }) {
    this.typeSuggestions =
      this.typesData()?.filter((t) =>
        t.name.toLowerCase().includes(event.query.toLowerCase())
      ) || [];
  }

  filterSorts(event: { query: string }) {
    this.sortSuggestions = this.sortOptions.filter((s) =>
      s.label.toLowerCase().includes(event.query.toLowerCase())
    );
  }

  onBrandSelect(brand: BrandResponse) {
    this.filterStore.setBrand(brand.id);
  }
  onBrandClear() {
    this.filterStore.setBrand(null);
  }
  onTypeSelect(type: TypeResponse) {
    this.filterStore.setType(type.id);
  }
  onTypeClear() {
    this.filterStore.setType(null);
  }
  onSortSelect(sort: { label: string; value: ProductSortingOptions }) {
    this.filterStore.setSort(sort.value);
  }
  onSortClear() {
    this.filterStore.setSort(ProductSortingOptions.NameAsc);
  }

  onPageChange(event: PaginatorState): void {
    this.filterStore.setPage(event.page || 0);
    this.filterStore.setPageSize(event.rows || 12);
  }

  onSearchChange(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.searchSubject.next(input.value);
  }

  clearFilters(): void {
    this.filterStore.resetFilters();
  }

  handleAddToCart(product: ProductResponse) {
    let basket = this.currentBasket.data();

    if (!basket) {
      const newBasketId = uuidv4();
      this.basketId.set(newBasketId);
      StorageUtils.setLocalItem(STORAGE_KEYS.BASKET_ID, newBasketId);
      basket = { id: newBasketId, items: [], shippingPrice: 0 };
    }

    const itemIndex = basket.items.findIndex((item) => item.id === product.id);
    let newItems = [...basket.items];

    if (itemIndex > -1) {
      newItems[itemIndex] = {
        ...newItems[itemIndex],
        quantity: newItems[itemIndex].quantity + 1,
      };
    } else {
      newItems.push({
        id: product.id,
        productName: product.name,
        pictureUrl: product.pictureUrl,
        price: product.price,
        quantity: 1,
      });
    }

    const updatedBasket: BasketDTO = { ...basket, items: newItems };

    this.updateBasketMutation.mutate(updatedBasket, {
      onSuccess: () => {
        this.toastService.showSuccess(
          'Added to Cart',
          `${product.name} has been added.`
        );
      },
      onError: (error: any) => {
        this.toastService.showError('Error', 'Could not add item to cart.');
        console.error(error);
      },
    });
  }
}
==== END ./src/app/features/products/components/product-list/product-list.component.ts ====
==== START ./src/app/features/products/queries/product.queries.ts ====
import { inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { lastValueFrom } from 'rxjs';
import { QueryClient } from '@tanstack/angular-query-experimental';
import { API_ENDPOINTS } from '../../../core/constants/api-endpoints';
import {
  ProductResponse,
  PaginatedResponse,
  ProductQueryParameters,
  BrandResponse,
  TypeResponse,
} from '@core/models';
import { API_URL } from 'app/app.config';

@Injectable({ providedIn: 'root' })
export class ProductQueries {
  private http = inject(HttpClient);
  private queryClient = inject(QueryClient);
  private apiUrl = inject(API_URL);

  // Query keys
  private static readonly PRODUCTS_KEY = ['products'];
  private static readonly PRODUCT_KEY = (id: number) => ['product', id];
  private static readonly BRANDS_KEY = ['brands'];
  private static readonly TYPES_KEY = ['types'];

  // Get paginated products with filter
  getProductsWithFilter(params: ProductQueryParameters) {
    return {
      queryKey: [...ProductQueries.PRODUCTS_KEY, params],
      queryFn: () => this.fetchProducts(params),
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: 1,
    };
  }

  // Get single product by id
  getProductById(id: number) {
    return {
      queryKey: ProductQueries.PRODUCT_KEY(id),
      queryFn: () => this.fetchProduct(id),
      enabled: !!id,
      staleTime: 10 * 60 * 1000, // 10 minutes
      retry: 1,
    };
  }

  // Get brands
  getBrands() {
    return {
      queryKey: ProductQueries.BRANDS_KEY,
      queryFn: () => this.fetchBrands(),
      staleTime: 30 * 60 * 1000, // 30 minutes
      retry: 1,
    };
  }

  // Get types
  getTypes() {
    return {
      queryKey: ProductQueries.TYPES_KEY,
      queryFn: () => this.fetchTypes(),
      staleTime: 30 * 60 * 1000, // 30 minutes
      retry: 1,
    };
  }

  // API methods
  private fetchProducts(
    params?: ProductQueryParameters
  ): Promise<PaginatedResponse<ProductResponse>> {
    const queryParams = new URLSearchParams();

    if (params) {
      if (params.brandId)
        queryParams.append('brandId', params.brandId.toString());
      if (params.typeId) queryParams.append('typeId', params.typeId.toString());
      if (params.sort) queryParams.append('sort', params.sort);
      if (params.search) queryParams.append('search', params.search);
      if (params.pageIndex)
        queryParams.append('pageIndex', params.pageIndex.toString());
      if (params.pageSize)
        queryParams.append('pageSize', params.pageSize.toString());
    }

    return lastValueFrom(
      this.http.get<PaginatedResponse<ProductResponse>>(
        `${this.apiUrl}${
          API_ENDPOINTS.PRODUCTS.GET_PRODUCTS
        }?${queryParams.toString()}`
      )
    );
  }

  private fetchProduct(id: number): Promise<ProductResponse> {
    return lastValueFrom(
      this.http.get<ProductResponse>(
        `${this.apiUrl}${API_ENDPOINTS.PRODUCTS.GET_PRODUCT(id)}`
      )
    );
  }

  private fetchBrands(): Promise<BrandResponse[]> {
    return lastValueFrom(
      this.http.get<BrandResponse[]>(
        `${this.apiUrl}${API_ENDPOINTS.PRODUCTS.GET_BRANDS}`
      )
    );
  }

  private fetchTypes(): Promise<TypeResponse[]> {
    return lastValueFrom(
      this.http.get<TypeResponse[]>(
        `${this.apiUrl}${API_ENDPOINTS.PRODUCTS.GET_TYPES}`
      )
    );
  }
}
==== END ./src/app/features/products/queries/product.queries.ts ====
==== START ./src/app/features/products/store/product-filter.store.ts ====
import {
  signalStore,
  withState,
  withComputed,
  withMethods,
  withHooks,
  patchState,
} from '@ngrx/signals';
import { computed, effect } from '@angular/core';
import { APP_CONSTANTS } from '../../../core/constants/app-constants';
import {
  ProductQueryParameters,
  ProductSortingOptions,
  FilterState,
} from '@core/models';
import { STORAGE_KEYS } from '../../../core/constants/storage-keys';

const initialState: FilterState = {
  filters: {
    pageIndex: 0,
    pageSize: APP_CONSTANTS.DEFAULT_PAGE_SIZE,
    sort: ProductSortingOptions.NameAsc,
  },
  isLoading: false,
  error: null,
};

export const ProductFilterStore = signalStore(
  { providedIn: 'root' },
  withState<FilterState>(initialState),
  withComputed(({ filters }) => ({
    // Computed selectors for derived state
    hasActiveFilters: computed(() => {
      const currentFilters = filters();
      return !!(
        currentFilters.brandId ||
        currentFilters.typeId ||
        (currentFilters.sort &&
          currentFilters.sort !== ProductSortingOptions.NameAsc) ||
        currentFilters.search
      );
    }),

    filtersForQuery: computed(() => {
      const currentFilters = filters();
      return {
        brandId: currentFilters.brandId || undefined,
        typeId: currentFilters.typeId || undefined,
        sort: currentFilters.sort || ProductSortingOptions.NameAsc,
        search: currentFilters.search || undefined,
        pageIndex: currentFilters.pageIndex || 0,
        pageSize: currentFilters.pageSize || APP_CONSTANTS.DEFAULT_PAGE_SIZE,
      };
    }),

    // Computed for pagination info
    paginationInfo: computed(() => {
      const currentFilters = filters();
      return {
        currentPage: currentFilters.pageIndex || 0,
        pageSize: currentFilters.pageSize || APP_CONSTANTS.DEFAULT_PAGE_SIZE,
        hasNextPage: true, // This would be computed based on total count from API
      };
    }),
  })),
  withMethods((store) => ({
    // Set complete filters
    setFilters: (filters: ProductQueryParameters) => {
      patchState(store, { filters, error: null });
    },

    // Update partial filters
    updateFilters: (filters: Partial<ProductQueryParameters>) => {
      const currentFilters = store.filters();
      patchState(store, {
        filters: { ...currentFilters, ...filters },
        error: null,
      });
    },

    // Reset filters to initial state
    resetFilters: () => {
      patchState(store, {
        filters: {
          pageIndex: 0,
          pageSize: APP_CONSTANTS.DEFAULT_PAGE_SIZE,
          sort: ProductSortingOptions.NameAsc,
        },
        error: null,
      });
    },

    // Individual filter setters with proper typing
    setBrand: (brandId: number | null) => {
      const currentFilters = store.filters();
      patchState(store, {
        filters: {
          ...currentFilters,
          brandId: brandId || undefined,
          pageIndex: 0, // Reset to first page when filter changes
        },
        error: null,
      });
    },

    setType: (typeId: number | null) => {
      const currentFilters = store.filters();
      patchState(store, {
        filters: {
          ...currentFilters,
          typeId: typeId || undefined,
          pageIndex: 0, // Reset to first page when filter changes
        },
        error: null,
      });
    },

    setSort: (sort: ProductSortingOptions) => {
      const currentFilters = store.filters();
      patchState(store, {
        filters: { ...currentFilters, sort, pageIndex: 0 },
        error: null,
      });
    },

    setSearch: (search: string | null) => {
      const currentFilters = store.filters();
      patchState(store, {
        filters: {
          ...currentFilters,
          search: search || undefined,
          pageIndex: 0, // Reset to first page when search changes
        },
        error: null,
      });
    },

    setPage: (pageIndex: number) => {
      const currentFilters = store.filters();
      patchState(store, {
        filters: { ...currentFilters, pageIndex },
        error: null,
      });
    },

    setPageSize: (pageSize: number) => {
      const currentFilters = store.filters();
      patchState(store, {
        filters: { ...currentFilters, pageSize, pageIndex: 0 },
        error: null,
      });
    },

    // Loading state management
    setLoading: (isLoading: boolean) => {
      patchState(store, { isLoading });
    },

    // Error handling
    setError: (error: string | null) => {
      patchState(store, { error });
    },

    clearError: () => {
      patchState(store, { error: null });
    },
  })),
  withHooks({
    onInit: (store) => {
      // Load filters from localStorage on initialization
      const savedFilters = localStorage.getItem(STORAGE_KEYS.PRODUCT_FILTERS);
      if (savedFilters) {
        try {
          const filters = JSON.parse(savedFilters);
          // Validate the sort field is a valid ProductSortingOptions value
          if (
            filters.sort &&
            !Object.values(ProductSortingOptions).includes(filters.sort)
          ) {
            filters.sort = ProductSortingOptions.NameAsc;
          }
          patchState(store, { filters });
        } catch (error) {
          console.warn('Failed to load filters from localStorage:', error);
        }
      }
      // Auto-save filters to localStorage when they change
      effect(() => {
        localStorage.setItem(
          STORAGE_KEYS.PRODUCT_FILTERS,
          JSON.stringify(store.filters())
        );
      });
    },
  })
);

// Export the filters signal directly
export const filters = (ProductFilterStore as any).filters;
==== END ./src/app/features/products/store/product-filter.store.ts ====
==== START ./src/app/features/user/components/login/login.component.html ====
<div class="flex items-center justify-center min-h-screen bg-gray-50 p-4">
  <p-card
    header="Welcome Back!"
    subheader="Sign in to continue"
    styleClass="w-full max-w-md shadow-2xl"
  >
    <form
      [formGroup]="loginForm"
      (ngSubmit)="onSubmit()"
      class="flex flex-col gap-6"
    >
      <!-- Email Field -->
      <div class="flex flex-col gap-1">
        <label for="email" class="font-semibold text-gray-700">Email</label>
        <div class="relative">
          <input
            pInputText
            id="email"
            type="email"
            placeholder="you@example.com"
            formControlName="email"
            class="w-full pl-10 pr-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            [class.border-red-500]="isInvalid('email')"
            aria-label="Email address"
            aria-describedby="email-error"
            tabindex="0"
          />
          <i
            class="pi pi-envelope absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"
          ></i>
        </div>
        @if (isInvalid('email')) {
        <p-message
          id="email-error"
          severity="error"
          size="small"
          variant="simple"
          class="mt-1"
        >
          @if (loginForm.get('email')?.errors?.['required']) { Email is
          required. } @if (loginForm.get('email')?.errors?.['email']) { Please
          enter a valid email address. }
        </p-message>
        }
      </div>

      <!-- Password Field -->
      <div class="flex flex-col gap-1">
        <label for="password" class="font-semibold text-gray-700"
          >Password</label
        >
        <p-password
          id="password"
          placeholder="Enter your password"
          formControlName="password"
          [toggleMask]="true"
          [feedback]="false"
          class="w-full"
          [class.border-red-500]="isInvalid('password')"
          aria-label="Password"
          aria-describedby="password-error"
          tabindex="0"
        />
        @if (isInvalid('password')) {
        <p-message
          id="password-error"
          severity="error"
          size="small"
          variant="simple"
          class="mt-1"
        >
          @if (loginForm.get('password')?.errors?.['required']) { Password is
          required. } @if (loginForm.get('password')?.errors?.['minlength']) {
          Password must be at least 6 characters long. }
        </p-message>
        }
      </div>

      @if (loginError()) {
      <p-message severity="error" size="small" variant="simple" class="mt-2">
        Login failed. Please check your credentials and try again.
      </p-message>
      }

      <!-- Submit Button -->
      <p-button
        type="submit"
        [loading]="loginMutation.isPending()"
        [disabled]="loginForm.invalid || loginMutation.isPending()"
        class="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors duration-200"
        aria-label="Sign in to your account"
      >
        <span pButtonLabel>
          @if (loginMutation.isPending()) { Signing In... } @else { Sign In }
        </span>
      </p-button>
    </form>

    <ng-template pTemplate="footer">
      <div class="text-center text-sm text-gray-600">
        Don't have an account?
        <a
          routerLink="/user/register"
          class="font-semibold text-blue-600 hover:text-blue-700 hover:underline transition-colors duration-200"
          aria-label="Navigate to registration page"
        >
          Sign up
        </a>
      </div>
    </ng-template>
  </p-card>
</div>
==== END ./src/app/features/user/components/login/login.component.html ====
==== START ./src/app/features/user/components/login/login.component.scss ====
:host {
  display: block;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
}

.login-container {
  width: 100%;
  max-width: 400px;
}

.login-card {
  background: white;
  border-radius: 16px;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
  padding: 2.5rem;
  position: relative;
  overflow: hidden;
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #667eea, #764ba2);
  }
}

.login-header {
  text-align: center;
  margin-bottom: 2rem;
}

.login-title {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 0.5rem;
  line-height: 1.2;
}

.login-subtitle {
  color: #6b7280;
  font-size: 1rem;
  line-height: 1.5;
}

.login-form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.form-field {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.form-label {
  font-weight: 500;
  color: #374151;
  font-size: 0.875rem;
  margin-bottom: 0.25rem;
}

.form-input {
  width: 100%;
  transition: all 0.2s ease-in-out;
  
  ::ng-deep {
    .p-inputtext {
      width: 100%;
      padding: 0.75rem 1rem;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s ease-in-out;
      
      &:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      
      &.ng-invalid.ng-touched {
        border-color: #ef4444;
        box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
      }
      
      &.ng-valid {
        border-color: #10b981;
      }
    }
  }
}

.password-input-container {
  position: relative;
  
  ::ng-deep {
    .p-password {
      width: 100%;
      
      .p-password-input {
        width: 100%;
        padding: 0.75rem 1rem;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        font-size: 1rem;
        transition: all 0.2s ease-in-out;
        
        &:focus {
          outline: none;
          border-color: #667eea;
          box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        &.ng-invalid.ng-touched {
          border-color: #ef4444;
          box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
        }
        
        &.ng-valid {
          border-color: #10b981;
        }
      }
      
      .p-password-toggle {
        position: absolute;
        right: 0.75rem;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #6b7280;
        cursor: pointer;
        padding: 0.25rem;
        border-radius: 4px;
        transition: all 0.2s ease-in-out;
        
        &:hover {
          color: #374151;
          background-color: #f3f4f6;
        }
      }
    }
  }
}

.error-message {
  color: #ef4444;
  font-size: 0.875rem;
  margin-top: 0.25rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
  
  &::before {
    content: '⚠';
    font-size: 0.75rem;
  }
}

.form-actions {
  margin-top: 1rem;
}

.submit-btn {
  width: 100%;
  padding: 0.875rem 1.5rem;
  font-size: 1rem;
  font-weight: 600;
  border-radius: 8px;
  transition: all 0.2s ease-in-out;
  
  &:not(:disabled):hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
  }
  
  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  z-index: 10;
}

.loading-text {
  margin-top: 1rem;
  color: #6b7280;
  font-weight: 500;
}

.login-footer {
  margin-top: 2rem;
  text-align: center;
  padding-top: 1.5rem;
  border-top: 1px solid #e5e7eb;
}

.footer-text {
  color: #6b7280;
  font-size: 0.875rem;
}

.footer-link {
  color: #667eea;
  text-decoration: none;
  font-weight: 500;
  cursor: pointer;
  transition: color 0.2s ease-in-out;
  
  &:hover {
    color: #5a67d8;
    text-decoration: underline;
  }
}

// Message styling
p-message {
  margin-bottom: 1rem;
  
  ::ng-deep .p-message {
    border-radius: 8px;
    
    &.p-message-error {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #dc2626;
    }
  }
}

// Responsive adjustments
@media (max-width: 480px) {
  .login-card {
    padding: 2rem 1.5rem;
  }
  
  .login-title {
    font-size: 1.75rem;
  }
  
  .form-input {
    ::ng-deep .p-inputtext {
      padding: 0.625rem 0.875rem;
    }
  }
  
  .password-input-container {
    ::ng-deep .p-password .p-password-input {
      padding: 0.625rem 0.875rem;
    }
  }
} ==== END ./src/app/features/user/components/login/login.component.scss ====
==== START ./src/app/features/user/components/login/login.component.ts ====
import { Component, inject, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, Validators } from '@angular/forms';
import { Router, RouterLink } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { InputTextModule } from 'primeng/inputtext';
import { PasswordModule } from 'primeng/password';
import { MessageModule } from 'primeng/message';
import { injectMutation } from '@tanstack/angular-query-experimental';

import { UserQueries } from '../../queries/user.queries';
import { LoginRequest, UserResponse } from '@core/models';
import { AuthService } from '@core/services/auth.service';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    RouterLink,
    ButtonModule,
    CardModule,
    InputTextModule,
    PasswordModule,
    MessageModule,
  ],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss'],
})
export class LoginComponent {
  private userQueries = inject(UserQueries);
  private authService = inject(AuthService);
  private fb = inject(FormBuilder);
  private router = inject(Router);

  loginForm = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(6)]],
  });

  loginMutation = injectMutation(() => this.userQueries.login());

  // Computed signals for template usage
  isLoginPending = computed(() => this.loginMutation.isPending());
  loginError = computed(() => this.loginMutation.error());

  // Helper method for form validation
  isInvalid(controlName: string): boolean {
    const control = this.loginForm.get(controlName);
    return control
      ? control.invalid && (control.touched || control.dirty)
      : false;
  }

  get email() {
    return this.loginForm.get('email');
  }
  get password() {
    return this.loginForm.get('password');
  }

  onSubmit(): void {
    if (this.loginForm.valid) {
      const request: LoginRequest = {
        email: this.loginForm.value.email!,
        password: this.loginForm.value.password!,
      };

      this.loginMutation.mutate(request, {
        onSuccess: (user: UserResponse) => {
          this.authService.setAuthState(user);
          this.router.navigate(['/']);
        },
        onError: (error: any) => {
          console.error('Login failed:', error);
        },
      });
    } else {
      this.loginForm.markAllAsTouched();
    }
  }
}
==== END ./src/app/features/user/components/login/login.component.ts ====
==== START ./src/app/features/user/components/profile/profile.component.html ====
<div class="container mx-auto px-4 py-8">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold text-gray-900 mb-8">User Profile</h1>

    @if (profileQuery.isPending()) {
    <div class="flex justify-center items-center h-64">
      <p-progress-spinner class="w-12 h-12" />
    </div>
    } @if (profileQuery.error()) {
    <p-message severity="error" size="small" variant="simple" class="mb-4">
      Failed to load profile information.
    </p-message>
    } @if (profileQuery.data()) {
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <!-- Profile Information -->
      <div class="lg:col-span-2">
        <p-card header="Profile Information" styleClass="h-fit shadow-md">
          <div class="space-y-4">
            <div class="flex items-center justify-between">
              <span class="font-semibold text-gray-700">Email:</span>
              <span class="text-gray-900">{{
                profileQuery.data()?.email
              }}</span>
            </div>
            <p-divider></p-divider>
            <div class="flex items-center justify-between">
              <span class="font-semibold text-gray-700">Display Name:</span>
              <span class="text-gray-900">{{
                profileQuery.data()?.displayName
              }}</span>
            </div>
            <p-divider></p-divider>
            <div class="flex items-center justify-between">
              <span class="font-semibold text-gray-700">Account Status:</span>
              <p-tag value="Active" severity="success"></p-tag>
            </div>
          </div>
        </p-card>
      </div>

      <!-- Quick Actions -->
      <div class="space-y-4">
        <p-card header="Quick Actions" styleClass="h-fit shadow-md">
          <div class="space-y-3">
            <p-button
              label="Edit Profile"
              icon="pi pi-user-edit"
              [rounded]="true"
              class="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors duration-200"
              (click)="editProfile()"
              aria-label="Edit profile"
            ></p-button>
            <p-button
              label="Change Password"
              icon="pi pi-lock"
              [outlined]="true"
              [rounded]="true"
              class="w-full py-3 border border-gray-300 hover:bg-gray-50 text-gray-700 font-semibold rounded-lg transition-colors duration-200"
              (click)="changePassword()"
              aria-label="Change password"
            ></p-button>
            <p-button
              label="View Orders"
              icon="pi pi-shopping-bag"
              [outlined]="true"
              [rounded]="true"
              class="w-full py-3 border border-gray-300 hover:bg-gray-50 text-gray-700 font-semibold rounded-lg transition-colors duration-200"
              (click)="viewOrders()"
              aria-label="View orders"
            ></p-button>
          </div>
        </p-card>

        <p-card header="Account Security" styleClass="h-fit shadow-md">
          <div class="space-y-3">
            <div class="flex items-center justify-between">
              <span class="text-sm text-gray-600">Two-Factor Auth</span>
              <p-tag value="Disabled" severity="warning"></p-tag>
            </div>
            <p-button
              label="Enable 2FA"
              icon="pi pi-shield"
              [rounded]="true"
              class="w-full py-2 bg-yellow-600 hover:bg-yellow-700 text-white font-semibold rounded-lg transition-colors duration-200"
              (click)="enable2FA()"
              aria-label="Enable two-factor authentication"
            ></p-button>
          </div>
        </p-card>
      </div>
    </div>

    <!-- Account Statistics -->
    <div class="mt-8">
      <p-card header="Account Statistics" styleClass="shadow-md">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <div class="text-center">
            <div class="text-3xl font-bold text-blue-600">0</div>
            <div class="text-sm text-gray-600">Total Orders</div>
          </div>
          <div class="text-center">
            <div class="text-3xl font-bold text-green-600">$0.00</div>
            <div class="text-sm text-gray-600">Total Spent</div>
          </div>
          <div class="text-center">
            <div class="text-3xl font-bold text-purple-600">0</div>
            <div class="text-sm text-gray-600">Wishlist Items</div>
          </div>
        </div>
      </p-card>
    </div>
    }
  </div>
</div>
==== END ./src/app/features/user/components/profile/profile.component.html ====
==== START ./src/app/features/user/components/profile/profile.component.scss ====
// Profile Component Styles
.profile {
  &__header {
    color: #1f2937;
    font-weight: 700;
  }
  
  &__card {
    transition: box-shadow 0.3s ease;
    
    &:hover {
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }
  }
  
  &__stat {
    transition: transform 0.2s ease;
    
    &:hover {
      transform: scale(1.05);
    }
  }
  
  &__button {
    transition: all 0.2s ease;
    
    &:hover {
      transform: translateY(-1px);
    }
  }
  
  &__divider {
    border-color: #e5e7eb;
  }
} ==== END ./src/app/features/user/components/profile/profile.component.scss ====
==== START ./src/app/features/user/components/profile/profile.component.ts ====
import { Component, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { CardModule } from 'primeng/card';
import { ButtonModule } from 'primeng/button';
import { DividerModule } from 'primeng/divider';
import { TagModule } from 'primeng/tag';
import { MessageModule } from 'primeng/message';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { AuthService } from '@core/services/auth.service';
import { UserResponse } from '@core/models';
import { injectQuery } from '@tanstack/angular-query-experimental';
import { lastValueFrom } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../../../environments/environment';
import { API_ENDPOINTS } from '@core/constants/api-endpoints';
import { InputTextModule } from 'primeng/inputtext';
import { PasswordModule } from 'primeng/password';

@Component({
  selector: 'app-profile',
  standalone: true,
  imports: [
    CommonModule,
    CardModule,
    ButtonModule,
    DividerModule,
    TagModule,
    MessageModule,
    ProgressSpinnerModule,
    InputTextModule,
    PasswordModule,
  ],
  templateUrl: './profile.component.html',
  styleUrls: ['./profile.component.scss'],
})
export class ProfileComponent {
  private http = inject(HttpClient);
  private router = inject(Router);
  private authService = inject(AuthService);

  // Query for user profile data
  profileQuery = injectQuery(() => ({
    queryKey: ['profile'],
    queryFn: () =>
      lastValueFrom(
        this.http.get<UserResponse>(
          `${environment.apiUrl}${API_ENDPOINTS.AUTH.CURRENT_USER}`
        )
      ),
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 1,
  }));

  editProfile(): void {
    // TODO: Navigate to edit profile page
    console.log('Edit profile clicked');
  }

  changePassword(): void {
    // TODO: Navigate to change password page
    console.log('Change password clicked');
  }

  viewOrders(): void {
    this.router.navigate(['/orders']);
  }

  enable2FA(): void {
    // TODO: Implement 2FA setup
    console.log('Enable 2FA clicked');
  }
}
==== END ./src/app/features/user/components/profile/profile.component.ts ====
==== START ./src/app/features/user/components/register/register.component.html ====
<div class="flex items-center justify-center min-h-screen bg-gray-50 p-4">
  <p-card
    header="Create Account"
    subheader="Join us and start shopping today"
    styleClass="w-full max-w-lg shadow-2xl"
  >
    @if (registerMutation.error()) {
    <p-message severity="error" size="small" variant="simple" class="mb-4">
      Registration failed: {{ registerMutation.error()?.errorMessage }}
    </p-message>
    }

    <form
      [formGroup]="registerForm"
      (ngSubmit)="onSubmit()"
      class="flex flex-col gap-6"
    >
      <!-- Display Name Field -->
      <div class="flex flex-col gap-1">
        <label for="displayName" class="font-semibold text-gray-700"
          >Full Name</label
        >
        <input
          pInputText
          id="displayName"
          type="text"
          placeholder="Enter your full name"
          formControlName="displayName"
          class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          [class.border-red-500]="isInvalid('displayName')"
          aria-label="Full name"
          aria-describedby="displayName-error"
          tabindex="0"
        />
        @if (isInvalid('displayName')) {
        <p-message
          id="displayName-error"
          severity="error"
          size="small"
          variant="simple"
          class="mt-1"
        >
          @if (registerForm.get('displayName')?.errors?.['required']) { Full
          name is required. } @if
          (registerForm.get('displayName')?.errors?.['minlength']) { Full name
          must be at least 2 characters. }
        </p-message>
        }
      </div>

      <!-- Username Field -->
      <div class="flex flex-col gap-1">
        <label for="userName" class="font-semibold text-gray-700"
          >Username</label
        >
        <input
          pInputText
          id="userName"
          type="text"
          placeholder="Enter your username"
          formControlName="userName"
          class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          [class.border-red-500]="isInvalid('userName')"
          aria-label="Username"
          aria-describedby="userName-error"
          tabindex="0"
        />
        @if (isInvalid('userName')) {
        <p-message
          id="userName-error"
          severity="error"
          size="small"
          variant="simple"
          class="mt-1"
        >
          @if (registerForm.get('userName')?.errors?.['required']) { Username is
          required. } @if (registerForm.get('userName')?.errors?.['minlength'])
          { Username must be at least 3 characters. }
        </p-message>
        }
      </div>

      <!-- Email Field -->
      <div class="flex flex-col gap-1">
        <label for="email" class="font-semibold text-gray-700">Email</label>
        <div class="relative">
          <input
            pInputText
            id="email"
            type="email"
            placeholder="Enter your email"
            formControlName="email"
            (blur)="checkEmailAvailability()"
            class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            [class.border-red-500]="isInvalid('email')"
            aria-label="Email address"
            aria-describedby="email-error email-status"
            tabindex="0"
          />
          @if (emailChecked() && !checkEmailMutation.isPending()) {
          <div class="absolute right-3 top-1/2 transform -translate-y-1/2">
            @if (checkEmailMutation.error()) {
            <i
              class="pi pi-times-circle text-red-500 text-lg"
              aria-label="Email already exists"
            ></i>
            } @else {
            <i
              class="pi pi-check-circle text-green-500 text-lg"
              aria-label="Email available"
            ></i>
            }
          </div>
          }
        </div>
        @if (isInvalid('email')) {
        <p-message
          id="email-error"
          severity="error"
          size="small"
          variant="simple"
          class="mt-1"
        >
          @if (registerForm.get('email')?.errors?.['required']) { Email is
          required. } @if (registerForm.get('email')?.errors?.['email']) {
          Please enter a valid email address. }
        </p-message>
        } @if (emailChecked() && !checkEmailMutation.isPending()) {
        <p-message
          id="email-status"
          [severity]="checkEmailMutation.error() ? 'error' : 'success'"
          size="small"
          variant="simple"
          class="mt-1"
        >
          @if (checkEmailMutation.error()) { Email already exists. } @else {
          Email available. }
        </p-message>
        }
      </div>

      <!-- Phone Number Field -->
      <div class="flex flex-col gap-1">
        <label for="phoneNumber" class="font-semibold text-gray-700"
          >Phone Number (Optional)</label
        >
        <input
          pInputText
          id="phoneNumber"
          type="tel"
          placeholder="Enter your phone number"
          formControlName="phoneNumber"
          class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          aria-label="Phone number"
          tabindex="0"
        />
      </div>

      <!-- Password Field -->
      <div class="flex flex-col gap-1">
        <label for="password" class="font-semibold text-gray-700"
          >Password</label
        >
        <p-password
          id="password"
          placeholder="Enter your password"
          formControlName="password"
          [toggleMask]="true"
          [feedback]="true"
          class="w-full"
          aria-label="Password"
          aria-describedby="password-error"
          tabindex="0"
        />
        @if (isInvalid('password')) {
        <p-message
          id="password-error"
          severity="error"
          size="small"
          variant="simple"
          class="mt-1"
        >
          @if (registerForm.get('password')?.errors?.['required']) { Password is
          required. } @if (registerForm.get('password')?.errors?.['minlength'])
          { Password must be at least 6 characters. }
        </p-message>
        }
      </div>

      <!-- Confirm Password Field -->
      <div class="flex flex-col gap-1">
        <label for="confirmPassword" class="font-semibold text-gray-700"
          >Confirm Password</label
        >
        <p-password
          id="confirmPassword"
          placeholder="Confirm your password"
          formControlName="confirmPassword"
          [invalid]="isInvalid('confirmPassword')"
          [toggleMask]="true"
          [feedback]="false"
          class="w-full"
          aria-label="Confirm password"
          aria-describedby="confirmPassword-error"
          tabindex="0"
        />
        @if (isInvalid('confirmPassword')) {
        <p-message
          id="confirmPassword-error"
          severity="error"
          size="small"
          variant="simple"
          class="mt-1"
        >
          @if (registerForm.get('confirmPassword')?.errors?.['required']) {
          Please confirm your password. } @if
          (registerForm.get('confirmPassword')?.errors?.['passwordMismatch']) {
          Passwords do not match. }
        </p-message>
        }
      </div>

      <!-- Submit Button -->
      <p-button
        type="submit"
        [loading]="registerMutation.isPending()"
        [disabled]="registerMutation.isPending() || registerForm.invalid"
        [rounded]="true"
        class="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors duration-200"
        aria-label="Create account"
      >
        <span pButtonLabel>
          @if (registerMutation.isPending()) { Creating Account... } @else {
          Create Account }
        </span>
      </p-button>
    </form>

    @if (registerMutation.isPending()) {
    <div class="flex items-center justify-center mt-4">
      <p-progress-spinner class="w-8 h-8" />
      <span class="ml-2 text-gray-600">Creating your account...</span>
    </div>
    }

    <ng-template pTemplate="footer">
      <div class="text-center text-sm text-gray-600">
        Already have an account?
        <a
          routerLink="/user/login"
          class="font-semibold text-blue-600 hover:text-blue-700 hover:underline transition-colors duration-200"
          aria-label="Navigate to login page"
        >
          Sign in here
        </a>
      </div>
    </ng-template>
  </p-card>
</div>
==== END ./src/app/features/user/components/register/register.component.html ====
==== START ./src/app/features/user/components/register/register.component.scss ====
 ==== END ./src/app/features/user/components/register/register.component.scss ====
==== START ./src/app/features/user/components/register/register.component.ts ====
import { Component, inject, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import {
  ReactiveFormsModule,
  FormBuilder,
  FormGroup,
  Validators,
} from '@angular/forms';
import { Router, RouterLink } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { InputTextModule } from 'primeng/inputtext';
import { PasswordModule } from 'primeng/password';
import { MessageModule } from 'primeng/message';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { injectMutation } from '@tanstack/angular-query-experimental';

import { UserQueries } from '../../queries/user.queries';
import { RegisterRequest, UserResponse } from '@core/models';
import { AuthService } from '@core/services/auth.service';

@Component({
  selector: 'app-register',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    RouterLink,
    ButtonModule,
    CardModule,
    InputTextModule,
    PasswordModule,
    MessageModule,
    ProgressSpinnerModule,
  ],
  templateUrl: './register.component.html',
  styleUrls: ['./register.component.scss'],
})
export class RegisterComponent {
  private userQueries = inject(UserQueries);
  private authService = inject(AuthService);
  private fb = inject(FormBuilder);
  private router = inject(Router);

  registerForm: FormGroup = this.fb.group(
    {
      displayName: ['', [Validators.required, Validators.minLength(2)]],
      userName: ['', [Validators.required, Validators.minLength(3)]],
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      confirmPassword: ['', [Validators.required]],
      phoneNumber: [''],
    },
    { validators: this.passwordMatchValidator }
  );

  registerMutation = injectMutation(() => this.userQueries.register());
  checkEmailMutation = injectMutation(() => this.userQueries.checkEmail());

  emailChecked = signal(false);

  isInvalid(controlName: string): boolean {
    const control = this.registerForm.get(controlName);
    return control
      ? control.invalid && (control.touched || control.dirty)
      : false;
  }

  passwordMatchValidator(form: FormGroup) {
    const password = form.get('password');
    const confirmPassword = form.get('confirmPassword');
    return password &&
      confirmPassword &&
      password.value === confirmPassword.value
      ? null
      : { passwordMismatch: true };
  }

  checkEmailAvailability(): void {
    const emailControl = this.registerForm.get('email');
    if (emailControl?.valid && emailControl.value) {
      this.emailChecked.set(true);
      this.checkEmailMutation.mutate(emailControl.value);
    }
  }

  onSubmit(): void {
    if (this.registerForm.valid) {
      const request: RegisterRequest = this.registerForm.value;
      this.registerMutation.mutate(request, {
        onSuccess: (user: UserResponse) => {
          this.authService.setAuthState(user);
          this.router.navigate(['/']);
        },
        onError: (error: any) => {
          console.error('Registration failed:', error);
        },
      });
    } else {
      this.registerForm.markAllAsTouched();
    }
  }
}
==== END ./src/app/features/user/components/register/register.component.ts ====
==== START ./src/app/features/user/queries/user.queries.ts ====
import { inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { lastValueFrom } from 'rxjs';
import { QueryClient } from '@tanstack/angular-query-experimental';
import { API_ENDPOINTS } from '../../../core/constants/api-endpoints';
import {
  UserResponse,
  LoginRequest,
  RegisterRequest,
  CurrentUserResponse,
  EmailCheckRequest,
  EmailCheckResponse,
  AddressDTO,
  ErrorDetails,
} from '@core/models';
import { API_URL } from 'app/app.config';
import { StorageUtils } from '@shared/utils/storage.utils';
import { STORAGE_KEYS } from '../../../core/constants/storage-keys';

@Injectable({ providedIn: 'root' })
export class UserQueries {
  private http = inject(HttpClient);
  private queryClient = inject(QueryClient);
  private apiUrl = inject(API_URL);

  // Query keys
  private static readonly CURRENT_USER_KEY = ['currentUser'];
  private static readonly ADDRESS_KEY = ['address'];

  // Get current user
  getCurrentUser() {
    return {
      queryKey: UserQueries.CURRENT_USER_KEY,
      queryFn: () => this.fetchCurrentUser(),
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: 1,
    };
  }

  // Get user address
  getAddress() {
    return {
      queryKey: UserQueries.ADDRESS_KEY,
      queryFn: () => this.fetchAddress(),
      staleTime: 10 * 60 * 1000, // 10 minutes
      retry: 1,
    };
  }

  // Login mutation
  login() {
    return {
      mutationFn: (request: LoginRequest) => this.loginUser(request),
      onSuccess: (data: UserResponse) => {
        StorageUtils.setLocalItem(STORAGE_KEYS.AUTH_TOKEN, data.token);
        StorageUtils.setLocalItem(STORAGE_KEYS.CURRENT_USER, data);
        this.queryClient.invalidateQueries({
          queryKey: UserQueries.CURRENT_USER_KEY,
        });
      },
      onError: (error: ErrorDetails) => {
        console.error('Login failed:', error.errorMessage);
      },
      retry: 1,
    };
  }

  // Register mutation
  register() {
    return {
      mutationFn: (request: RegisterRequest) => this.registerUser(request),
      onSuccess: (data: UserResponse) => {
        StorageUtils.setLocalItem(STORAGE_KEYS.AUTH_TOKEN, data.token);
        StorageUtils.setLocalItem(STORAGE_KEYS.CURRENT_USER, data);
        this.queryClient.invalidateQueries({
          queryKey: UserQueries.CURRENT_USER_KEY,
        });
      },
      onError: (error: ErrorDetails) => {
        console.error('Registration failed:', error.errorMessage);
      },
      retry: 1,
    };
  }

  // Check email mutation
  checkEmail() {
    return {
      mutationFn: (email: string) => this.checkEmailExists(email),
      onError: (error: ErrorDetails) => {
        console.error('Email check failed:', error.errorMessage);
      },
      retry: 1,
    };
  }

  // Update address mutation
  updateAddress() {
    return {
      mutationFn: (address: AddressDTO) => this.updateUserAddress(address),
      onSuccess: () => {
        this.queryClient.invalidateQueries({
          queryKey: UserQueries.ADDRESS_KEY,
        });
      },
      onError: (error: ErrorDetails) => {
        console.error('Address update failed:', error.errorMessage);
      },
      retry: 3,
    };
  }

  // API methods
  private fetchCurrentUser(): Promise<CurrentUserResponse> {
    return lastValueFrom(
      this.http.get<CurrentUserResponse>(
        `${this.apiUrl}${API_ENDPOINTS.AUTH.CURRENT_USER}`
      )
    );
  }

  private fetchAddress(): Promise<AddressDTO> {
    return lastValueFrom(
      this.http.get<AddressDTO>(`${this.apiUrl}${API_ENDPOINTS.AUTH.ADDRESS}`)
    );
  }

  private loginUser(request: LoginRequest): Promise<UserResponse> {
    return lastValueFrom(
      this.http.post<UserResponse>(
        `${this.apiUrl}${API_ENDPOINTS.AUTH.LOGIN}`,
        request
      )
    );
  }

  private registerUser(request: RegisterRequest): Promise<UserResponse> {
    return lastValueFrom(
      this.http.post<UserResponse>(
        `${this.apiUrl}${API_ENDPOINTS.AUTH.REGISTER}`,
        request
      )
    );
  }

  private checkEmailExists(email: string): Promise<EmailCheckResponse> {
    return lastValueFrom(
      this.http.get<EmailCheckResponse>(
        `${this.apiUrl}${API_ENDPOINTS.AUTH.EMAIL_CHECK}/${email}`
      )
    );
  }

  private updateUserAddress(address: AddressDTO): Promise<AddressDTO> {
    return lastValueFrom(
      this.http.put<AddressDTO>(
        `${this.apiUrl}${API_ENDPOINTS.AUTH.ADDRESS}`,
        address
      )
    );
  }
}
==== END ./src/app/features/user/queries/user.queries.ts ====
==== START ./src/app/shared/components/button/button.component.html ====
<p-button
  [label]="label"
  [icon]="icon"
  [iconPos]="iconPos"
  [disabled]="disabled"
  [loading]="loading"
  [size]="size"
  [severity]="severity"
  [rounded]="rounded"
  [outlined]="outlined"
  [text]="text"
  [raised]="raised"
  [class]="customClass"
  (onClick)="onClick.emit($event)"
  [attr.aria-label]="ariaLabel"
  [attr.aria-disabled]="disabled"
>
  <ng-content></ng-content>
</p-button>
==== END ./src/app/shared/components/button/button.component.html ====
==== START ./src/app/shared/components/button/button.component.scss ====
:host {
  display: inline-block;
} ==== END ./src/app/shared/components/button/button.component.scss ====
==== START ./src/app/shared/components/button/button.component.ts ====
import { Component, Input, Output, EventEmitter } from '@angular/core';
import { ButtonModule } from 'primeng/button';
import { CommonModule } from '@angular/common';

export type ButtonType =
  | 'primary'
  | 'secondary'
  | 'success'
  | 'danger'
  | 'warning'
  | 'info';

@Component({
  selector: 'app-button',
  standalone: true,
  imports: [CommonModule, ButtonModule],
  templateUrl: './button.component.html',
  styleUrls: ['./button.component.scss'],
})
export class ButtonComponent {
  @Input() label: string = '';
  @Input() icon: string = '';
  @Input() iconPos: 'left' | 'right' = 'left';
  @Input() disabled: boolean = false;
  @Input() loading: boolean = false;
  @Input() size: 'small' | 'large' = 'small';
  @Input() severity: 'primary' | 'secondary' | 'success' | 'danger' | 'info' =
    'primary';
  @Input() rounded: boolean = true;
  @Input() outlined: boolean = false;
  @Input() text: boolean = false;
  @Input() raised: boolean = true;
  @Input() customClass: string = '';
  @Input() ariaLabel: string = '';

  @Output() onClick = new EventEmitter<any>();

  get severityClass(): string {
    const severityMap: Record<ButtonType, string> = {
      primary: 'p-button-primary',
      secondary: 'p-button-secondary',
      success: 'p-button-success',
      danger: 'p-button-danger',
      warning: 'p-button-warning',
      info: 'p-button-info',
    };
    return severityMap[this.severity] || 'p-button-primary';
  }
}
==== END ./src/app/shared/components/button/button.component.ts ====
==== START ./src/app/shared/components/footer/footer.component.html ====
<footer
  class="w-full bg-gray-900 text-gray-200 py-8 mt-auto"
  role="contentinfo"
>
  <div class="max-w-7xl mx-auto px-4 grid grid-cols-1 md:grid-cols-4 gap-8">
    <div>
      <h3 class="font-bold mb-4 text-white">About</h3>
      <ul class="space-y-2">
        <li>
          <a routerLink="/about" class="hover:text-white transition-colors"
            >About Us</a
          >
        </li>
        <li>
          <a routerLink="/careers" class="hover:text-white transition-colors"
            >Careers</a
          >
        </li>
        <li>
          <a routerLink="/press" class="hover:text-white transition-colors"
            >Press</a
          >
        </li>
      </ul>
    </div>
    <div>
      <h3 class="font-bold mb-4 text-white">Customer Service</h3>
      <ul class="space-y-2">
        <li>
          <a routerLink="/contact" class="hover:text-white transition-colors"
            >Contact Us</a
          >
        </li>
        <li>
          <a routerLink="/returns" class="hover:text-white transition-colors"
            >Returns</a
          >
        </li>
        <li>
          <a routerLink="/orders" class="hover:text-white transition-colors"
            >Order Tracking</a
          >
        </li>
      </ul>
    </div>
    <div>
      <h3 class="font-bold mb-4 text-white">Information</h3>
      <ul class="space-y-2">
        <li>
          <a routerLink="/terms" class="hover:text-white transition-colors"
            >Terms & Conditions</a
          >
        </li>
        <li>
          <a routerLink="/privacy" class="hover:text-white transition-colors"
            >Privacy Policy</a
          >
        </li>
        <li>
          <a routerLink="/faqs" class="hover:text-white transition-colors"
            >FAQs</a
          >
        </li>
      </ul>
    </div>
    <div>
      <h3 class="font-bold mb-4 text-white">Follow Us</h3>
      <div class="flex gap-4 mt-2">
        <a
          href="https://facebook.com"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Facebook"
          class="hover:text-blue-400 transition-colors p-2 rounded-lg hover:bg-gray-800"
        >
          <i class="pi pi-facebook text-lg"></i>
        </a>
        <a
          href="https://twitter.com"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Twitter"
          class="hover:text-blue-400 transition-colors p-2 rounded-lg hover:bg-gray-800"
        >
          <i class="pi pi-twitter text-lg"></i>
        </a>
        <a
          href="https://instagram.com"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Instagram"
          class="hover:text-pink-400 transition-colors p-2 rounded-lg hover:bg-gray-800"
        >
          <i class="pi pi-instagram text-lg"></i>
        </a>
        <a
          href="https://linkedin.com"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="LinkedIn"
          class="hover:text-blue-400 transition-colors p-2 rounded-lg hover:bg-gray-800"
        >
          <i class="pi pi-linkedin text-lg"></i>
        </a>
      </div>
    </div>
  </div>
  <div
    class="text-center text-sm text-gray-400 mt-8 pt-8 border-t border-gray-800"
  >
    &copy; {{ currentYear }} Boon. All rights reserved.
  </div>
</footer>
==== END ./src/app/shared/components/footer/footer.component.html ====
==== START ./src/app/shared/components/footer/footer.component.scss ====
/* Custom styles for footer if needed. Most styles are handled by Tailwind CSS. */ ==== END ./src/app/shared/components/footer/footer.component.scss ====
==== START ./src/app/shared/components/footer/footer.component.ts ====
import { Component } from '@angular/core';
import { RouterLink } from '@angular/router';

@Component({
  selector: 'app-footer',
  standalone: true,
  templateUrl: './footer.component.html',
  styleUrls: ['./footer.component.scss'],
  imports: [RouterLink], // Import only the directive we need
})
export class FooterComponent {
  currentYear = new Date().getFullYear();
}
==== END ./src/app/shared/components/footer/footer.component.ts ====
==== START ./src/app/shared/components/input-text/input-text.component.ts ====
import { Component, forwardRef, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import {
  ControlValueAccessor,
  FormsModule,
  NG_VALUE_ACCESSOR,
} from '@angular/forms';
import { InputTextModule } from 'primeng/inputtext';
import { MessageModule } from 'primeng/message';
import { noop } from 'rxjs';

@Component({
  selector: 'app-input-text',
  standalone: true,
  imports: [CommonModule, FormsModule, InputTextModule, MessageModule],
  template: `
    <div class="flex flex-col gap-1">
      @if (label) {
      <label [for]="inputId" class="font-semibold text-gray-700">{{
        label
      }}</label>
      }
      <input
        pInputText
        [id]="inputId"
        [type]="type"
        [placeholder]="placeholder"
        [value]="value"
        [disabled]="disabled"
        [invalid]="invalid"
        class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
        [attr.aria-label]="ariaLabel"
        [attr.aria-describedby]="errorId"
        [attr.tabindex]="tabindex"
        (input)="onInputChange($event)"
        (blur)="onBlur()"
        (focus)="onFocus()"
      />
      @if (invalid && errorMessage) {
      <p-message [id]="errorId" severity="error" size="small" variant="simple">
        {{ errorMessage }}
      </p-message>
      }
    </div>
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => InputTextComponent),
      multi: true,
    },
  ],
})
export class InputTextComponent implements ControlValueAccessor {
  @Input() type: string = 'text';
  @Input() placeholder: string = '';
  @Input() label: string = '';
  @Input() inputId: string = '';
  @Input() ariaLabel: string = '';
  @Input() tabindex: string = '0';
  @Input() invalid: boolean = false;
  @Input() errorMessage: string = '';

  value: string = '';
  disabled: boolean = false;

  get errorId(): string {
    return this.inputId ? `${this.inputId}-error` : 'input-error';
  }

  onChange: (value: string) => void = noop;
  onTouched: () => void = noop;

  onInputChange(event: any): void {
    const value = event.target.value;
    this.value = value;
    this.onChange(value);
  }

  onBlur(): void {
    this.onTouched();
  }

  onFocus(): void {
    // Optional: handle focus if needed
  }

  writeValue(value: string): void {
    this.value = value || '';
  }

  registerOnChange(fn: (value: string) => void): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }

  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
}
==== END ./src/app/shared/components/input-text/input-text.component.ts ====
==== START ./src/app/shared/components/loading-spinner/loading-spinner.component.html ====
<div
  class="loading-spinner"
  [class.overlay]="overlay"
  [class.small]="size === 'small'"
  [class.medium]="size === 'medium'"
  [class.large]="size === 'large'"
  [attr.aria-label]="ariaLabel"
  role="status"
>
  <div class="spinner"></div>
  @if (message) {
  <div class="message">{{ message }}</div>
  }
</div>
==== END ./src/app/shared/components/loading-spinner/loading-spinner.component.html ====
==== START ./src/app/shared/components/loading-spinner/loading-spinner.component.scss ====
.loading-spinner {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1rem;
}

.loading-spinner.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 9999;
}

.spinner {
  border: 3px solid #f3f3f3;
  border-top: 3px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-spinner.small .spinner {
  width: 20px;
  height: 20px;
  border-width: 2px;
}

.loading-spinner.medium .spinner {
  width: 40px;
  height: 40px;
  border-width: 3px;
}

.loading-spinner.large .spinner {
  width: 60px;
  height: 60px;
  border-width: 4px;
}

.message {
  color: #666;
  font-size: 0.875rem;
  text-align: center;
}

.overlay .message {
  color: white;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
} ==== END ./src/app/shared/components/loading-spinner/loading-spinner.component.scss ====
==== START ./src/app/shared/components/loading-spinner/loading-spinner.component.ts ====
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-loading-spinner',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './loading-spinner.component.html',
  styleUrls: ['./loading-spinner.component.scss'],
})
export class LoadingSpinnerComponent {
  @Input() size: 'small' | 'medium' | 'large' = 'medium';
  @Input() message: string = '';
  @Input() overlay: boolean = false;
  @Input() ariaLabel: string = 'Loading...';
}
==== END ./src/app/shared/components/loading-spinner/loading-spinner.component.ts ====
==== START ./src/app/shared/components/navbar/navbar.component.html ====
<nav
  class="w-full bg-white/80 backdrop-blur-lg border-b border-gray-200 shadow-sm sticky top-0 z-[1020]"
>
  <div
    class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 flex items-center justify-between h-16"
  >
    <!-- Logo and Desktop Nav -->
    <div class="flex items-center gap-8">
      <a routerLink="/" class="flex items-center gap-2 flex-shrink-0">
        <div
          class="w-8 h-8 bg-primary-600 rounded-lg flex items-center justify-center text-white font-bold text-lg"
        >
          B
        </div>
        <span class="font-bold text-xl text-gray-900 hidden sm:block"
          >Boon</span
        >
      </a>
      <ul class="hidden lg:flex gap-6 text-sm font-medium text-gray-700">
        <li>
          <a
            routerLink="/products"
            routerLinkActive="text-primary-600"
            [routerLinkActiveOptions]="{ exact: true }"
            class="hover:text-primary-600 transition-colors"
            >Shop All</a
          >
        </li>
      </ul>
    </div>

    <!-- User Actions and Mobile Menu -->
    <div class="flex items-center gap-2">
      <p-button
        icon="pi pi-shopping-cart"
        [rounded]="true"
        [text]="true"
        severity="secondary"
        routerLink="/cart"
        pBadge
        [value]="cartItemCount() > 0 ? cartItemCount().toString() : ''"
      ></p-button>

      @if(isAuthenticated()){
      <p-button
        icon="pi pi-user"
        [label]="currentUser()?.displayName"
        (onClick)="menu.toggle($event)"
        [text]="true"
        severity="secondary"
      />
      <p-tieredMenu #menu [model]="userMenuItems" [popup]="true"></p-tieredMenu>
      } @else {
      <p-button
        label="Log In"
        routerLink="/user/login"
        styleClass="hidden sm:inline-flex"
        size="small"
      ></p-button>
      <p-button
        icon="pi pi-user"
        [rounded]="true"
        [text]="true"
        severity="secondary"
        routerLink="/user/login"
        styleClass="sm:hidden"
      ></p-button>
      }

      <p-button
        icon="pi pi-bars"
        [text]="true"
        severity="secondary"
        (click)="sidebarVisible.set(true)"
        class="lg:hidden"
      ></p-button>
    </div>
  </div>
</nav>

<!-- Mobile Sidebar -->
<p-drawer [(visible)]="sidebarVisible" position="right">
  <ng-template pTemplate="header">
    <span class="font-bold text-xl">Menu</span>
  </ng-template>
  <ul class="flex flex-col gap-4 text-lg p-4">
    <li>
      <a
        routerLink="/products"
        (click)="sidebarVisible.set(false)"
        class="p-2 block"
        >Shop All</a
      >
    </li>
    <li>
      <a
        routerLink="/orders"
        (click)="sidebarVisible.set(false)"
        class="p-2 block"
        >My Orders</a
      >
    </li>
    <li>
      <a
        routerLink="/user/profile"
        (click)="sidebarVisible.set(false)"
        class="p-2 block"
        >Profile</a
      >
    </li>
    @if(isAuthenticated()){
    <li>
      <a (click)="logout()" class="p-2 block cursor-pointer text-red-500"
        >Logout</a
      >
    </li>
    }
  </ul>
</p-drawer>
==== END ./src/app/shared/components/navbar/navbar.component.html ====
==== START ./src/app/shared/components/navbar/navbar.component.scss ====
/* Custom styles for navbar if needed. Most styles are handled by Tailwind CSS. */ ==== END ./src/app/shared/components/navbar/navbar.component.scss ====
==== START ./src/app/shared/components/navbar/navbar.component.ts ====
import { Component, computed, inject, signal } from '@angular/core';
import { RouterLink, RouterLinkActive } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { TieredMenuModule } from 'primeng/tieredmenu';
import { BadgeModule } from 'primeng/badge';
import { MenuItem } from 'primeng/api';
import { injectQuery } from '@tanstack/angular-query-experimental';
import { CartQueries } from '../../../features/cart/queries/cart.queries';
import { AuthService } from '@core/services/auth.service';
import { StorageUtils } from '@shared/utils/storage.utils';
import { STORAGE_KEYS } from '@core/constants/storage-keys';
import { BasketItemDTO } from '@core/models';
import { DrawerModule } from 'primeng/drawer';
import { UserResponse } from '@core/models/user.model';

@Component({
  selector: 'app-navbar',
  standalone: true,
  templateUrl: './navbar.component.html',
  styleUrls: ['./navbar.component.scss'],
  imports: [
    RouterLink,
    DrawerModule,
    RouterLinkActive,
    ButtonModule,
    TieredMenuModule,
    BadgeModule,
  ],
})
export class NavbarComponent {
  private cartQueries = inject(CartQueries);
  private authService = inject(AuthService);

  sidebarVisible = signal(false);

  private basketId = computed(
    () => StorageUtils.getLocalItem<string>(STORAGE_KEYS.BASKET_ID) || 'default'
  );

  basketQuery = injectQuery(() =>
    this.cartQueries.getBasketById(this.basketId())
  );

  isAuthenticated = computed(() => this.authService.isAuthenticated());
  currentUser = computed(() => {
    if (this.authService.isLoggedIn()) {
      return StorageUtils.getLocalItem<UserResponse>(STORAGE_KEYS.CURRENT_USER);
    }
    return null;
  });

  cartItemCount = computed(() => {
    const basket = this.basketQuery.data();
    if (!basket?.items) return 0;
    return basket.items.reduce(
      (acc: number, item: BasketItemDTO) => acc + item.quantity,
      0
    );
  });

  userMenuItems: MenuItem[] = [
    {
      label: 'Profile',
      icon: 'pi pi-user',
      routerLink: '/user/profile',
    },
    {
      label: 'My Orders',
      icon: 'pi pi-shopping-bag',
      routerLink: '/orders',
    },
    {
      separator: true,
    },
    {
      label: 'Logout',
      icon: 'pi pi-sign-out',
      command: () => this.logout(),
    },
  ];

  logout(): void {
    this.authService.logout();
  }
}
==== END ./src/app/shared/components/navbar/navbar.component.ts ====
==== START ./src/app/shared/components/not-found/not-found.component.html ====
<div
  class="flex flex-col items-center justify-center min-h-[60vh] text-center p-6"
>
  <h1 class="text-7xl font-bold text-gray-800 mb-4" aria-label="404">404</h1>
  <p class="text-xl text-gray-600 mb-6" role="status">Page Not Found</p>
  <a
    routerLink="/landing"
    class="inline-block bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 transition"
    aria-label="Go to landing page"
  >
    Go to Landing Page
  </a>
</div>
==== END ./src/app/shared/components/not-found/not-found.component.html ====
==== START ./src/app/shared/components/not-found/not-found.component.scss ====
// No additional styles needed; styled with Tailwind CSS ==== END ./src/app/shared/components/not-found/not-found.component.scss ====
==== START ./src/app/shared/components/not-found/not-found.component.ts ====
import { Component } from '@angular/core';
import { RouterModule } from '@angular/router';

@Component({
  standalone: true,
  selector: 'app-not-found',
  imports: [RouterModule],
  templateUrl: './not-found.component.html',
  styleUrl: './not-found.component.scss',
})
export class NotFoundComponent {}
==== END ./src/app/shared/components/not-found/not-found.component.ts ====
==== START ./src/app/shared/components/password-input/password-input.component.ts ====
import { Component, forwardRef, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import {
  ControlValueAccessor,
  FormsModule,
  NG_VALUE_ACCESSOR,
} from '@angular/forms';
import { PasswordModule } from 'primeng/password';
import { noop } from 'rxjs';

@Component({
  selector: 'app-password-input',
  standalone: true,
  imports: [CommonModule, FormsModule, PasswordModule],
  template: `
    <p-password
      [placeholder]="placeholder"
      [styleClass]="styleClass"
      [disabled]="disabled"
      [toggleMask]="toggleMask"
      [feedback]="feedback"
      [promptLabel]="promptLabel"
      [weakLabel]="weakLabel"
      [mediumLabel]="mediumLabel"
      [strongLabel]="strongLabel"
      (input)="onInputChange($event)"
      (blur)="onBlur()"
      (focus)="onFocus()"
    />
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => PasswordInputComponent),
      multi: true,
    },
  ],
})
export class PasswordInputComponent implements ControlValueAccessor {
  @Input() placeholder: string = '';
  @Input() styleClass: string = '';
  @Input() toggleMask: boolean = true;
  @Input() feedback: boolean = false;
  @Input() promptLabel: string = 'Enter password';
  @Input() weakLabel: string = 'Too simple';
  @Input() mediumLabel: string = 'Average complexity';
  @Input() strongLabel: string = 'Complex password';

  value: string = '';
  disabled: boolean = false;

  onChange: (value: string) => void = noop;
  onTouched: () => void = noop;

  onInputChange(event: any): void {
    const value = event.target.value;
    this.value = value;
    this.onChange(value);
  }

  onBlur(): void {
    this.onTouched();
  }

  onFocus(): void {
    // Optional: handle focus if needed
  }

  writeValue(value: string): void {
    this.value = value || '';
  }

  registerOnChange(fn: (value: string) => void): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }

  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
}
==== END ./src/app/shared/components/password-input/password-input.component.ts ====
==== START ./src/app/shared/pipes/capitalize.pipe.ts ====
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'capitalize',
  standalone: true,
})
export class CapitalizePipe implements PipeTransform {
  transform(value: string, type: 'first' | 'all' | 'title' = 'first'): string {
    if (!value) {
      return value;
    }

    switch (type) {
      case 'first':
        return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();

      case 'all':
        return value.toUpperCase();

      case 'title':
        return value.replace(
          /\w\S*/g,
          (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
        );

      default:
        return value;
    }
  }
}
==== END ./src/app/shared/pipes/capitalize.pipe.ts ====
==== START ./src/app/shared/pipes/currency-format.pipe.ts ====
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'currencyFormat',
  standalone: true,
})
export class CurrencyFormatPipe implements PipeTransform {
  transform(
    value: number | string,
    currency: string = 'USD',
    locale: string = 'en-US'
  ): string {
    if (value === null || value === undefined) {
      return '';
    }

    const numericValue = typeof value === 'string' ? parseFloat(value) : value;

    if (isNaN(numericValue)) {
      return '';
    }

    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(numericValue);
  }
}
==== END ./src/app/shared/pipes/currency-format.pipe.ts ====
==== START ./src/app/shared/pipes/date-format.pipe.ts ====
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'dateFormat',
  standalone: true,
})
export class DateFormatPipe implements PipeTransform {
  transform(
    value: string | Date,
    format: string = 'medium',
    locale: string = 'en-US'
  ): string {
    if (!value) {
      return '';
    }

    const date = typeof value === 'string' ? new Date(value) : value;

    if (isNaN(date.getTime())) {
      return '';
    }

    switch (format) {
      case 'short':
        return new Intl.DateTimeFormat(locale, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
        }).format(date);

      case 'long':
        return new Intl.DateTimeFormat(locale, {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        }).format(date);

      case 'time':
        return new Intl.DateTimeFormat(locale, {
          hour: '2-digit',
          minute: '2-digit',
        }).format(date);

      case 'relative':
        return this.getRelativeTimeString(date);

      default: // medium
        return new Intl.DateTimeFormat(locale, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        }).format(date);
    }
  }

  private getRelativeTimeString(date: Date): string {
    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diffInSeconds < 60) {
      return 'Just now';
    }

    const diffInMinutes = Math.floor(diffInSeconds / 60);
    if (diffInMinutes < 60) {
      return `${diffInMinutes} minute${diffInMinutes > 1 ? 's' : ''} ago`;
    }

    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) {
      return `${diffInHours} hour${diffInHours > 1 ? 's' : ''} ago`;
    }

    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 7) {
      return `${diffInDays} day${diffInDays > 1 ? 's' : ''} ago`;
    }

    return this.transform(date, 'short');
  }
}
==== END ./src/app/shared/pipes/date-format.pipe.ts ====
==== START ./src/app/shared/pipes/safe-html.pipe.ts ====
import { Pipe, PipeTransform } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

@Pipe({
  name: 'safeHtml',
  standalone: true,
})
export class SafeHtmlPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}

  transform(value: string): SafeHtml {
    return this.sanitizer.bypassSecurityTrustHtml(value);
  }
}
==== END ./src/app/shared/pipes/safe-html.pipe.ts ====
==== START ./src/app/shared/pipes/truncate-text.pipe.ts ====
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'truncateText',
  standalone: true,
})
export class TruncateTextPipe implements PipeTransform {
  transform(
    value: string,
    maxLength: number = 50,
    suffix: string = '...'
  ): string {
    if (!value || value.length <= maxLength) {
      return value;
    }

    return value.substring(0, maxLength - suffix.length) + suffix;
  }
}
==== END ./src/app/shared/pipes/truncate-text.pipe.ts ====
==== START ./src/app/shared/utils/cart.utils.ts ====
import { computed, signal } from '@angular/core';
import { BasketDTO, BasketItemDTO } from '../../core/models/basket.model';

export class CartUtils {
  // Signals for cart state
  private cartItems = signal<BasketItemDTO[]>([]);
  private isLoading = signal(false);

  // Computed signals for derived state
  public itemCount = computed(() => {
    return this.cartItems().reduce((total, item) => total + item.quantity, 0);
  });

  public total = computed(() => {
    return this.cartItems().reduce(
      (total, item) => total + item.price * item.quantity,
      0
    );
  });

  public isEmpty = computed(() => {
    return this.cartItems().length === 0;
  });

  public hasItems = computed(() => {
    return this.cartItems().length > 0;
  });

  // Methods to update cart state
  setCartItems(items: BasketItemDTO[]): void {
    this.cartItems.set(items);
  }

  updateCartFromBasket(basket: BasketDTO): void {
    this.cartItems.set(basket.items);
  }

  addItem(item: BasketItemDTO): void {
    const currentItems = this.cartItems();
    const existingItemIndex = currentItems.findIndex((i) => i.id === item.id);

    if (existingItemIndex >= 0) {
      // Update existing item quantity
      const updatedItems = [...currentItems];
      updatedItems[existingItemIndex] = {
        ...updatedItems[existingItemIndex],
        quantity: updatedItems[existingItemIndex].quantity + item.quantity,
      };
      this.cartItems.set(updatedItems);
    } else {
      // Add new item
      this.cartItems.set([...currentItems, item]);
    }
  }

  updateItemQuantity(productId: number, quantity: number): void {
    const currentItems = this.cartItems();
    const itemIndex = currentItems.findIndex((i) => i.id === productId);

    if (itemIndex >= 0) {
      const updatedItems = [...currentItems];
      updatedItems[itemIndex] = {
        ...updatedItems[itemIndex],
        quantity,
      };
      this.cartItems.set(updatedItems);
    }
  }

  removeItem(productId: number): void {
    const currentItems = this.cartItems();
    const filteredItems = currentItems.filter((item) => item.id !== productId);
    this.cartItems.set(filteredItems);
  }

  clearCart(): void {
    this.cartItems.set([]);
  }

  setLoading(loading: boolean): void {
    this.isLoading.set(loading);
  }

  // Utility methods
  getItemById(productId: number): BasketItemDTO | undefined {
    return this.cartItems().find((item) => item.id === productId);
  }

  getItemQuantity(productId: number): number {
    const item = this.getItemById(productId);
    return item?.quantity || 0;
  }

  // Formatting utilities
  formatCurrency(amount: number): string {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
    }).format(amount);
  }

  formatTotal(): string {
    return this.formatCurrency(this.total());
  }
}
==== END ./src/app/shared/utils/cart.utils.ts ====
==== START ./src/app/shared/utils/formatting.utils.ts ====
export class FormattingUtils {
  // Currency formatting
  static formatCurrency(
    amount: number,
    currency: string = 'USD',
    locale: string = 'en-US'
  ): string {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(amount);
  }

  // Number formatting
  static formatNumber(
    value: number,
    locale: string = 'en-US',
    options?: Intl.NumberFormatOptions
  ): string {
    return new Intl.NumberFormat(locale, options).format(value);
  }

  // Percentage formatting
  static formatPercentage(value: number, decimals: number = 1): string {
    return `${value.toFixed(decimals)}%`;
  }

  // Date formatting
  static formatDate(
    date: Date | string,
    options?: Intl.DateTimeFormatOptions,
    locale: string = 'en-US'
  ): string {
    const dateObj = typeof date === 'string' ? new Date(date) : date;
    return new Intl.DateTimeFormat(locale, options).format(dateObj);
  }

  // Relative time formatting
  static formatRelativeTime(date: Date | string): string {
    const dateObj = typeof date === 'string' ? new Date(date) : date;
    const now = new Date();
    const diffInSeconds = Math.floor(
      (now.getTime() - dateObj.getTime()) / 1000
    );

    if (diffInSeconds < 60) {
      return 'Just now';
    }

    const diffInMinutes = Math.floor(diffInSeconds / 60);
    if (diffInMinutes < 60) {
      return `${diffInMinutes} minute${diffInMinutes > 1 ? 's' : ''} ago`;
    }

    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) {
      return `${diffInHours} hour${diffInHours > 1 ? 's' : ''} ago`;
    }

    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 7) {
      return `${diffInDays} day${diffInDays > 1 ? 's' : ''} ago`;
    }

    return this.formatDate(dateObj, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  }

  // File size formatting
  static formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  // Phone number formatting
  static formatPhoneNumber(phone: string): string {
    const cleaned = phone.replace(/\D/g, '');
    const match = cleaned.match(/^(\d{3})(\d{3})(\d{4})$/);

    if (match) {
      return `(${match[1]}) ${match[2]}-${match[3]}`;
    }

    return phone;
  }

  // Credit card number formatting
  static formatCreditCard(cardNumber: string): string {
    const cleaned = cardNumber.replace(/\D/g, '');
    const match = cleaned.match(/^(\d{4})(\d{4})(\d{4})(\d{4})$/);

    if (match) {
      return `${match[1]} ${match[2]} ${match[3]} ${match[4]}`;
    }

    return cardNumber;
  }

  // Truncate text
  static truncateText(
    text: string,
    maxLength: number,
    suffix: string = '...'
  ): string {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - suffix.length) + suffix;
  }

  // Capitalize first letter
  static capitalize(text: string): string {
    return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
  }

  // Title case
  static titleCase(text: string): string {
    return text.replace(
      /\w\S*/g,
      (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
    );
  }

  // Slugify text
  static slugify(text: string): string {
    return text
      .toLowerCase()
      .trim()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
}
==== END ./src/app/shared/utils/formatting.utils.ts ====
==== START ./src/app/shared/utils/http.utils.ts ====
import { HttpHeaders, HttpParams } from '@angular/common/http';

export class HttpUtils {
  // Create headers
  static createHeaders(headers?: Record<string, string>): HttpHeaders {
    let httpHeaders = new HttpHeaders({
      'Content-Type': 'application/json',
    });

    if (headers) {
      Object.entries(headers).forEach(([key, value]) => {
        httpHeaders = httpHeaders.set(key, value);
      });
    }

    return httpHeaders;
  }

  // Create authorization header
  static createAuthHeader(token: string): HttpHeaders {
    return new HttpHeaders({
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    });
  }

  // Create params from object
  static createParams(params?: Record<string, any>): HttpParams {
    let httpParams = new HttpParams();

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== null && value !== undefined) {
          if (Array.isArray(value)) {
            value.forEach((item) => {
              httpParams = httpParams.append(key, item.toString());
            });
          } else {
            httpParams = httpParams.set(key, value.toString());
          }
        }
      });
    }

    return httpParams;
  }

  // Build URL with query parameters
  static buildUrl(baseUrl: string, params?: Record<string, any>): string {
    if (!params) {
      return baseUrl;
    }

    const queryParams = Object.entries(params)
      .filter(([_, value]) => value !== null && value !== undefined)
      .map(([key, value]) => {
        if (Array.isArray(value)) {
          return value
            .map(
              (item) => `${encodeURIComponent(key)}=${encodeURIComponent(item)}`
            )
            .join('&');
        }
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      })
      .join('&');

    return queryParams ? `${baseUrl}?${queryParams}` : baseUrl;
  }

  // Parse query string
  static parseQueryString(queryString: string): Record<string, string> {
    const params: Record<string, string> = {};
    const searchParams = new URLSearchParams(queryString);

    for (const [key, value] of searchParams.entries()) {
      params[key] = value;
    }

    return params;
  }

  // Extract filename from Content-Disposition header
  static extractFilename(contentDisposition: string): string | null {
    const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
    const matches = filenameRegex.exec(contentDisposition);

    if (matches != null && matches[1]) {
      return matches[1].replace(/['"]/g, '');
    }

    return null;
  }

  // Check if response is successful
  static isSuccessResponse(status: number): boolean {
    return status >= 200 && status < 300;
  }

  // Check if response is a client error
  static isClientError(status: number): boolean {
    return status >= 400 && status < 500;
  }

  // Check if response is a server error
  static isServerError(status: number): boolean {
    return status >= 500 && status < 600;
  }

  // Get error message from response
  static getErrorMessage(error: any): string {
    if (error?.error?.message) {
      return error.error.message;
    }

    if (error?.message) {
      return error.message;
    }

    if (typeof error === 'string') {
      return error;
    }

    return 'An unexpected error occurred';
  }

  // Retry logic
  static async retryRequest<T>(
    requestFn: () => Promise<T>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<T> {
    let lastError: any;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await requestFn();
      } catch (error) {
        lastError = error;

        if (attempt === maxRetries) {
          throw error;
        }

        // Wait before retrying
        await new Promise((resolve) => setTimeout(resolve, delay * attempt));
      }
    }

    throw lastError;
  }

  // Debounce function
  static debounce<T extends (...args: any[]) => any>(
    func: T,
    wait: number
  ): (...args: Parameters<T>) => void {
    let timeout: NodeJS.Timeout;

    return (...args: Parameters<T>) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
    };
  }

  // Throttle function
  static throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;

    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => (inThrottle = false), limit);
      }
    };
  }

  // Cancelable request wrapper
  static createCancelableRequest<T>(
    requestFn: (signal: AbortSignal) => Promise<T>
  ): { promise: Promise<T>; cancel: () => void } {
    const controller = new AbortController();

    return {
      promise: requestFn(controller.signal),
      cancel: () => controller.abort(),
    };
  }

  // Request timeout wrapper
  static withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    return Promise.race([
      promise,
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Request timeout')), timeoutMs)
      ),
    ]);
  }

  // Batch requests
  static async batchRequests<T>(
    requests: (() => Promise<T>)[],
    concurrency: number = 5
  ): Promise<T[]> {
    const results: T[] = [];
    const executing: Promise<void>[] = [];

    for (const request of requests) {
      const promise = request().then((result) => {
        results.push(result);
      });

      executing.push(promise);

      if (executing.length >= concurrency) {
        await Promise.race(executing);
        executing.splice(
          executing.findIndex((p) => p === promise),
          1
        );
      }
    }

    await Promise.all(executing);
    return results;
  }
}
==== END ./src/app/shared/utils/http.utils.ts ====
==== START ./src/app/shared/utils/storage.utils.ts ====
import { inject, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

export class StorageUtils {
  // Helper to check if running in browser
  static isBrowser(): boolean {
    try {
      const platformId =
        typeof ngDevMode !== 'undefined' ? inject(PLATFORM_ID) : 'browser';
      return isPlatformBrowser(platformId);
    } catch {
      // Fallback for direct browser usage
      return (
        typeof window !== 'undefined' && typeof localStorage !== 'undefined'
      );
    }
  }

  // Local Storage
  static setLocalItem(key: string, value: any): void {
    if (!this.isBrowser()) return;
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Failed to save to localStorage:', error);
    }
  }

  static getLocalItem<T>(key: string, defaultValue?: T): T | null {
    if (!this.isBrowser()) return defaultValue || null;
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue || null;
    } catch (error) {
      console.error('Failed to read from localStorage:', error);
      return defaultValue || null;
    }
  }

  static removeLocalItem(key: string): void {
    if (!this.isBrowser()) return;
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error('Failed to remove from localStorage:', error);
    }
  }

  static clearLocalStorage(): void {
    if (!this.isBrowser()) return;
    try {
      localStorage.clear();
    } catch (error) {
      console.error('Failed to clear localStorage:', error);
    }
  }

  // Session Storage
  static setSessionItem(key: string, value: any): void {
    if (!this.isBrowser()) return;
    try {
      sessionStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Failed to save to sessionStorage:', error);
    }
  }

  static getSessionItem<T>(key: string, defaultValue?: T): T | null {
    if (!this.isBrowser()) return defaultValue || null;
    try {
      const item = sessionStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue || null;
    } catch (error) {
      console.error('Failed to read from sessionStorage:', error);
      return defaultValue || null;
    }
  }

  static removeSessionItem(key: string): void {
    if (!this.isBrowser()) return;
    try {
      sessionStorage.removeItem(key);
    } catch (error) {
      console.error('Failed to remove from sessionStorage:', error);
    }
  }

  static clearSessionStorage(): void {
    if (!this.isBrowser()) return;
    try {
      sessionStorage.clear();
    } catch (error) {
      console.error('Failed to clear sessionStorage:', error);
    }
  }

  // Utility methods
  static hasLocalItem(key: string): boolean {
    if (!this.isBrowser()) return false;
    return localStorage.getItem(key) !== null;
  }

  static hasSessionItem(key: string): boolean {
    if (!this.isBrowser()) return false;
    return sessionStorage.getItem(key) !== null;
  }

  // Get all keys from storage
  static getLocalKeys(): string[] {
    if (!this.isBrowser()) return [];
    return Object.keys(localStorage);
  }

  static getSessionKeys(): string[] {
    if (!this.isBrowser()) return [];
    return Object.keys(sessionStorage);
  }

  // Storage size utilities
  static getLocalStorageSize(): number {
    if (!this.isBrowser()) return 0;
    let size = 0;
    for (const key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        size += localStorage[key].length + key.length;
      }
    }
    return size;
  }

  static getSessionStorageSize(): number {
    if (!this.isBrowser()) return 0;
    let size = 0;
    for (const key in sessionStorage) {
      if (sessionStorage.hasOwnProperty(key)) {
        size += sessionStorage[key].length + key.length;
      }
    }
    return size;
  }

  // Check if storage is available
  static isLocalStorageAvailable(): boolean {
    if (!this.isBrowser()) return false;
    try {
      const test = '__localStorage_test__';
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    } catch {
      return false;
    }
  }

  static isSessionStorageAvailable(): boolean {
    if (!this.isBrowser()) return false;
    try {
      const test = '__sessionStorage_test__';
      sessionStorage.setItem(test, test);
      sessionStorage.removeItem(test);
      return true;
    } catch {
      return false;
    }
  }

  // Batch operations
  static setMultipleLocalItems(items: Record<string, any>): void {
    if (!this.isBrowser()) return;
    Object.entries(items).forEach(([key, value]) => {
      this.setLocalItem(key, value);
    });
  }

  static getMultipleLocalItems<T>(keys: string[]): Record<string, T | null> {
    if (!this.isBrowser()) return {};
    const result: Record<string, T | null> = {};
    keys.forEach((key) => {
      result[key] = this.getLocalItem<T>(key);
    });
    return result;
  }

  static removeMultipleLocalItems(keys: string[]): void {
    if (!this.isBrowser()) return;
    keys.forEach((key) => {
      this.removeLocalItem(key);
    });
  }

  // Expiration utilities
  static setLocalItemWithExpiry(
    key: string,
    value: any,
    expiryInMinutes: number
  ): void {
    if (!this.isBrowser()) return;
    const item = {
      value,
      expiry: Date.now() + expiryInMinutes * 60 * 1000,
    };
    this.setLocalItem(key, item);
  }

  static getLocalItemWithExpiry<T>(key: string): T | null {
    if (!this.isBrowser()) return null;
    const item = this.getLocalItem<{ value: T; expiry: number }>(key);

    if (!item) {
      return null;
    }

    if (Date.now() > item.expiry) {
      this.removeLocalItem(key);
      return null;
    }

    return item.value;
  }

  // Encryption utilities (basic)
  static setEncryptedLocalItem(
    key: string,
    value: any,
    password: string
  ): void {
    if (!this.isBrowser()) return;
    try {
      const encrypted = btoa(JSON.stringify(value));
      this.setLocalItem(key, encrypted);
    } catch (error) {
      console.error('Failed to encrypt data:', error);
    }
  }

  static getEncryptedLocalItem<T>(key: string, password: string): T | null {
    if (!this.isBrowser()) return null;
    try {
      const encrypted = this.getLocalItem<string>(key);
      if (!encrypted) return null;

      const decrypted = JSON.parse(atob(encrypted));
      return decrypted;
    } catch (error) {
      console.error('Failed to decrypt data:', error);
      return null;
    }
  }
}
==== END ./src/app/shared/utils/storage.utils.ts ====
==== START ./src/app/shared/utils/validation.utils.ts ====
import { APP_CONSTANTS } from '../../core/constants/app-constants';

export class ValidationUtils {
  // Email validation
  static isValidEmail(email: string): boolean {
    return APP_CONSTANTS.EMAIL_REGEX.test(email);
  }

  // Password validation
  static isValidPassword(password: string): boolean {
    return password.length >= APP_CONSTANTS.PASSWORD_MIN_LENGTH;
  }

  // Required field validation
  static isRequired(value: any): boolean {
    return (
      value !== null && value !== undefined && value.toString().trim() !== ''
    );
  }

  // String length validation
  static isValidLength(value: string, min: number, max: number): boolean {
    return value.length >= min && value.length <= max;
  }

  // Number range validation
  static isInRange(value: number, min: number, max: number): boolean {
    return value >= min && value <= max;
  }

  // URL validation
  static isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  // Phone number validation (basic)
  static isValidPhone(phone: string): boolean {
    const phoneRegex = /^[\+]?[1-9][\d]{0,15}$/;
    return phoneRegex.test(phone.replace(/\s/g, ''));
  }

  // Postal code validation (US format)
  static isValidPostalCode(postalCode: string): boolean {
    const postalRegex = /^\d{5}(-\d{4})?$/;
    return postalRegex.test(postalCode);
  }

  // Credit card validation (Luhn algorithm)
  static isValidCreditCard(cardNumber: string): boolean {
    const cleanNumber = cardNumber.replace(/\s/g, '');
    if (!/^\d+$/.test(cleanNumber)) return false;

    let sum = 0;
    let isEven = false;

    for (let i = cleanNumber.length - 1; i >= 0; i--) {
      let digit = parseInt(cleanNumber.charAt(i));

      if (isEven) {
        digit *= 2;
        if (digit > 9) {
          digit -= 9;
        }
      }

      sum += digit;
      isEven = !isEven;
    }

    return sum % 10 === 0;
  }

  // Form validation helpers
  static getFieldError(
    fieldName: string,
    value: any,
    rules: ValidationRule[]
  ): string | null {
    for (const rule of rules) {
      const error = rule.validator(value);
      if (error) {
        return error;
      }
    }
    return null;
  }

  static validateForm(
    formData: any,
    validationRules: Record<string, ValidationRule[]>
  ): Record<string, string> {
    const errors: Record<string, string> = {};

    for (const [fieldName, rules] of Object.entries(validationRules)) {
      const error = this.getFieldError(fieldName, formData[fieldName], rules);
      if (error) {
        errors[fieldName] = error;
      }
    }

    return errors;
  }

  // Common validation rules
  static readonly RULES = {
    required: (value: any) =>
      !this.isRequired(value) ? 'This field is required' : null,
    email: (value: string) =>
      !this.isValidEmail(value) ? 'Please enter a valid email address' : null,
    password: (value: string) =>
      !this.isValidPassword(value)
        ? `Password must be at least ${APP_CONSTANTS.PASSWORD_MIN_LENGTH} characters`
        : null,
    minLength: (min: number) => (value: string) =>
      !this.isValidLength(value, min, Infinity)
        ? `Must be at least ${min} characters`
        : null,
    maxLength: (max: number) => (value: string) =>
      !this.isValidLength(value, 0, max)
        ? `Must be no more than ${max} characters`
        : null,
    phone: (value: string) =>
      !this.isValidPhone(value) ? 'Please enter a valid phone number' : null,
    postalCode: (value: string) =>
      !this.isValidPostalCode(value)
        ? 'Please enter a valid postal code'
        : null,
    creditCard: (value: string) =>
      !this.isValidCreditCard(value)
        ? 'Please enter a valid credit card number'
        : null,
  };
}

export interface ValidationRule {
  validator: (value: any) => string | null;
}
==== END ./src/app/shared/utils/validation.utils.ts ====
==== START ./src/environments/environment.prod.ts ====
export const environment = {
  production: true,
  apiUrl: 'https://api.boon-ecommerce.com',
  appName: 'Boon E-commerce',
  version: '1.0.0',
  debug: false,
};
==== END ./src/environments/environment.prod.ts ====
==== START ./src/environments/environment.ts ====
export const environment = {
  production: false,
  apiUrl: 'https://localhost:7003',
  stripePublishableKey:
    'pk_test_51RRa89PxTCVHi7x5Zb0oITKr6EeffXNDX9kzYZyr5KsyfSB1v9GuZYxdv2qZ8sxEdQkuDgOsjYJ721dRBsLI8a8Q00VRPHStrS',
  appName: 'Boon E-commerce',
  version: '1.0.0',
  debug: true,
};
==== END ./src/environments/environment.ts ====
==== START ./src/index.html ====
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>BoonFrontEnd</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>
==== END ./src/index.html ====
==== START ./src/main.server.ts ====
import { bootstrapApplication } from '@angular/platform-browser';
import { App } from './app/app';
import { config } from './app/app.config.server';

const bootstrap = () => bootstrapApplication(App, config);

export default bootstrap;
==== END ./src/main.server.ts ====
==== START ./src/main.ts ====
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { App } from './app/app';

bootstrapApplication(App, appConfig).catch((err) => console.error(err));
==== END ./src/main.ts ====
==== START ./src/server.ts ====
import {
  AngularNodeAppEngine,
  createNodeRequestHandler,
  isMainModule,
  writeResponseToNodeResponse,
} from '@angular/ssr/node';
import express from 'express';
import { join } from 'node:path';

const browserDistFolder = join(import.meta.dirname, '../browser');

const app = express();
const angularApp = new AngularNodeAppEngine();

/**
 * Example Express Rest API endpoints can be defined here.
 * Uncomment and define endpoints as necessary.
 *
 * Example:
 * ```ts
 * app.get('/api/{*splat}', (req, res) => {
 *   // Handle API request
 * });
 * ```
 */

/**
 * Serve static files from /browser
 */
app.use(
  express.static(browserDistFolder, {
    maxAge: '1y',
    index: false,
    redirect: false,
  }),
);

/**
 * Handle all other requests by rendering the Angular application.
 */
app.use((req, res, next) => {
  angularApp
    .handle(req)
    .then((response) =>
      response ? writeResponseToNodeResponse(response, res) : next(),
    )
    .catch(next);
});

/**
 * Start the server if this module is the main entry point.
 * The server listens on the port defined by the `PORT` environment variable, or defaults to 4000.
 */
if (isMainModule(import.meta.url)) {
  const port = process.env['PORT'] || 4000;
  app.listen(port, (error) => {
    if (error) {
      throw error;
    }

    console.log(`Node Express server listening on http://localhost:${port}`);
  });
}

/**
 * Request handler used by the Angular CLI (for dev-server and during build) or Firebase Cloud Functions.
 */
export const reqHandler = createNodeRequestHandler(app);
==== END ./src/server.ts ====
==== START ./src/styles/styles.css ====
/* This file is now empty as styles have been moved to src/styles.scss */
==== END ./src/styles/styles.css ====
==== START ./src/styles.scss ====
/* Import Tailwind CSS v4 */
@import "tailwindcss";

/* Import PrimeNG icons */
@import "primeicons/primeicons.css";

/* Global SCSS variables and mixins */
$primary-color: #3b82f6;
$secondary-color: #64748b;
$success-color: #059669;
$error-color: #dc2626;
$warning-color: #d97706;

/* Global styles */
* {
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  background-color: #f9fafb;
  color: #1f2937;
  line-height: 1.6;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f5f9;
}

::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Focus styles for accessibility */
*:focus {
  outline: 2px solid $primary-color;
  outline-offset: 2px;
}

/* Button focus styles */
button:focus {
  outline: 2px solid $primary-color;
  outline-offset: 2px;
}

/* Link focus styles */
a:focus {
  outline: 2px solid $primary-color;
  outline-offset: 2px;
}

/* Form input focus styles */
input:focus,
textarea:focus,
select:focus {
  outline: 2px solid $primary-color;
  outline-offset: 2px;
}

/* Utility classes */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* Loading states */
.loading {
  opacity: 0.6;
  pointer-events: none;
}

/* Error states */
.error {
  border-color: $error-color;
  color: $error-color;
}

.error-message {
  color: $error-color;
  font-size: 0.875rem;
  margin-top: 0.25rem;
}

/* Success states */
.success {
  border-color: $success-color;
  color: $success-color;
}

.success-message {
  color: $success-color;
  font-size: 0.875rem;
  margin-top: 0.25rem;
}

/* Responsive text utilities */
.text-responsive {
  font-size: clamp(0.875rem, 2vw, 1rem);
}

.heading-responsive {
  font-size: clamp(1.5rem, 4vw, 2.25rem);
}

/* Animation utilities */
.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.slide-in {
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
}

/* Print styles */
@media print {
  .no-print {
    display: none !important;
  }

  body {
    background: white !important;
    color: black !important;
  }
}
==== END ./src/styles.scss ====
==== START ./tailwind.config.js ====
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{html,ts}", "./src/**/*.scss", "./src/**/*.css"],
  theme: {
    extend: {
      colors: {
        primary: {
          50: "#eff6ff",
          100: "#dbeafe",
          200: "#bfdbfe",
          300: "#93c5fd",
          400: "#60a5fa",
          500: "#3b82f6",
          600: "#2563eb",
          700: "#1d4ed8",
          800: "#1e40af",
          900: "#1e3a8a",
          950: "#172554",
        },
        secondary: {
          50: "#f8fafc",
          100: "#f1f5f9",
          200: "#e2e8f0",
          300: "#cbd5e1",
          400: "#94a3b8",
          500: "#64748b",
          600: "#475569",
          700: "#334155",
          800: "#1e293b",
          900: "#0f172a",
          950: "#020617",
        },
        success: {
          50: "#f0fdf4",
          100: "#dcfce7",
          200: "#bbf7d0",
          300: "#86efac",
          400: "#4ade80",
          500: "#22c55e",
          600: "#16a34a",
          700: "#15803d",
          800: "#166534",
          900: "#14532d",
          950: "#052e16",
        },
        error: {
          50: "#fef2f2",
          100: "#fee2e2",
          200: "#fecaca",
          300: "#fca5a5",
          400: "#f87171",
          500: "#ef4444",
          600: "#dc2626",
          700: "#b91c1c",
          800: "#991b1b",
          900: "#7f1d1d",
          950: "#450a0a",
        },
        warning: {
          50: "#fffbeb",
          100: "#fef3c7",
          200: "#fde68a",
          300: "#fcd34d",
          400: "#fbbf24",
          500: "#f59e0b",
          600: "#d97706",
          700: "#b45309",
          800: "#92400e",
          900: "#78350f",
          950: "#451a03",
        },
      },
      fontFamily: {
        sans: [
          "-apple-system",
          "BlinkMacSystemFont",
          '"Segoe UI"',
          "Roboto",
          "Oxygen",
          "Ubuntu",
          "Cantarell",
          '"Fira Sans"',
          '"Droid Sans"',
          '"Helvetica Neue"',
          "sans-serif",
        ],
      },
      animation: {
        "fade-in": "fadeIn 0.3s ease-in-out",
        "slide-in": "slideIn 0.3s ease-out",
        "bounce-in": "bounceIn 0.6s ease-out",
      },
      keyframes: {
        fadeIn: {
          "0%": { opacity: "0", transform: "translateY(10px)" },
          "100%": { opacity: "1", transform: "translateY(0)" },
        },
        slideIn: {
          "0%": { transform: "translateX(-100%)" },
          "100%": { transform: "translateX(0)" },
        },
        bounceIn: {
          "0%": { transform: "scale(0.3)", opacity: "0" },
          "50%": { transform: "scale(1.05)" },
          "70%": { transform: "scale(0.9)" },
          "100%": { transform: "scale(1)", opacity: "1" },
        },
      },
      boxShadow: {
        soft: "0 2px 8px rgba(0, 0, 0, 0.1)",
        medium: "0 4px 16px rgba(0, 0, 0, 0.15)",
        large: "0 8px 32px rgba(0, 0, 0, 0.2)",
      },
      borderRadius: {
        xl: "12px",
        "2xl": "16px",
      },
      spacing: {
        18: "4.5rem",
        88: "22rem",
      },
    },
  },
  plugins: [require("@tailwindcss/forms")],
};
==== END ./tailwind.config.js ====
==== START ./tsconfig.app.json ====
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": [
      "node"
    ],
    "baseUrl": "./src",
    "paths": {
      "@core/*": ["app/core/*"],
      "@shared/*": ["app/shared/*"],
      "@features/*": ["app/features/*"]
    }
  },
  "include": [
    "src/**/*.ts"
  ],
  "exclude": [
    "src/**/*.spec.ts"
  ]
}
==== END ./tsconfig.app.json ====
==== START ./tsconfig.json ====
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "experimentalDecorators": true,
    "importHelpers": true,
    "target": "ES2022",
    "module": "preserve"
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "typeCheckHostBindings": true,
    "strictTemplates": true
  },
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ]
}
==== END ./tsconfig.json ====
==== START ./tsconfig.spec.json ====
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.ts"
  ]
}
==== END ./tsconfig.spec.json ====
